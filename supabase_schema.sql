-- Consolidated Supabase schema for GH Media portal
-- Save and run in Supabase SQL editor (Project -> SQL)

-- Extensions
create extension if not exists "pgcrypto";

-- 1) Students
create table if not exists public.students (
  id uuid primary key default gen_random_uuid(),
  first_name text,
  last_name text,
  full_name text,
  email text,
  phone text,
  date_of_birth date,
  gender text,
  address text,
  level text,
  school text,
  program text,
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);
create unique index if not exists idx_students_email on public.students((lower(email))) where email is not null;
create index if not exists idx_students_phone on public.students(phone) where phone is not null;

-- 2) Programs (catalog)
create table if not exists public.programs (
  id uuid primary key default gen_random_uuid(),
  code text unique,
  name text not null,
  description text,
  level text,
  school text,
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);
create index if not exists idx_programs_school on public.programs(school);

-- 3) Courses (catalog)
create table if not exists public.courses (
  id uuid primary key default gen_random_uuid(),
  code text unique,
  title text not null,
  description text,
  credits int,
  program_id uuid references public.programs(id) on delete set null,
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);
create index if not exists idx_courses_program_id on public.courses(program_id);

-- 4) Registrations (student -> enrolment record)
create table if not exists public.registrations (
  id uuid primary key default gen_random_uuid(),
  student_id uuid references public.students(id) on delete cascade,
  level text,
  school text,
  program_id uuid references public.programs(id) on delete set null,
  program text,
  term text,
  courses jsonb default '[]'::jsonb,
  core_courses jsonb default '[]'::jsonb,
  status text default 'pending', -- pending, approved, cancelled
  notes text,
  created_at timestamptz default now()
);
create index if not exists idx_registrations_student_id on public.registrations(student_id);
create index if not exists idx_registrations_created_at on public.registrations(created_at desc);

-- 5) Payments (canonical payments table used for triggers and reporting)
create table if not exists public.payments (
  id uuid primary key default gen_random_uuid(),
  reference text unique,
  student_id uuid references public.students(id) on delete set null,
  registration_id uuid references public.registrations(id) on delete set null,
  amount numeric(12,2) not null default 0,
  currency text default 'GHS',
  payment_method text,
  status text, -- e.g. 'pending', 'paid', 'failed', 'refunded', 'approved'
  provider_response jsonb,
  phone text,
  student_name text,
  payment_type text, -- fees, hostel, application
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create index if not exists idx_payments_student_id on public.payments(student_id);
create index if not exists idx_payments_status on public.payments(status);
create index if not exists idx_payments_created_at on public.payments(created_at desc);

-- 6) SMS messages (queue & history)
create table if not exists public.sms_messages (
  id bigint generated by default as identity primary key,
  student_id uuid,
  recipient text,
  phone text,
  message text,
  template text,
  status text, -- 'intent_created', 'queued', 'sent', 'failed'
  gateway_response jsonb,
  meta jsonb default '{}'::jsonb,
  created_at timestamptz default now(),
  sent_at timestamptz
);
create index if not exists idx_sms_messages_student_id on public.sms_messages(student_id);
create index if not exists idx_sms_messages_status on public.sms_messages(status);

-- 7) Notifications (in-app notifications)
create table if not exists public.notifications (
  id uuid primary key default gen_random_uuid(),
  student_id uuid,
  message text not null,
  type text default 'admin_message',
  meta jsonb default '{}'::jsonb,
  read boolean default false,
  created_at timestamptz default now()
);
create index if not exists idx_notifications_student_id on public.notifications(student_id);
create index if not exists idx_notifications_student_unread on public.notifications(student_id, read) where (read = false);

-- 8) Admin users (optional light table if using external auth)
create table if not exists public.portal_users (
  id uuid primary key default gen_random_uuid(),
  email text unique not null,
  full_name text,
  role text default 'editor', -- admin, editor, viewer
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

-- 9) Trigger: enqueue SMS when payments are inserted/updated to paid/approved
create or replace function public.enqueue_sms_on_payment()
returns trigger
language plpgsql
as $$
begin
  if (tg_op = 'INSERT') then
    if (new.status is not null and lower(new.status) in ('paid','approved')) then
      perform public.enqueue_sms_for_payment(new);
    end if;
  elsif (tg_op = 'UPDATE') then
    if ( (old.status is distinct from new.status) and new.status is not null and lower(new.status) in ('paid','approved') ) then
      perform public.enqueue_sms_for_payment(new);
    end if;
  end if;
  return new;
end;
$$;

-- helper function used by trigger to keep logic tidy
create or replace function public.enqueue_sms_for_payment(p_row public.payments)
returns void
language plpgsql
as $$
declare
  _phone text := null;
  _student_phone text := null;
begin
  _phone := coalesce(p_row.phone, null);
  if _phone is null and p_row.student_id is not null then
    begin
      select phone into _student_phone from public.students where id = p_row.student_id limit 1;
    exception when others then
      _student_phone := null;
    end;
  end if;

  insert into public.sms_messages (student_id, phone, recipient, message, template, status, created_at)
  values (
    p_row.student_id,
    coalesce(_phone, _student_phone),
    coalesce(coalesce(_phone, _student_phone), ''),
    concat('GH TECHNICAL â€” Hi ', coalesce(p_row.student_name, ''), ', we received your payment of ', coalesce(p_row.amount::text, ''), ' ', coalesce(p_row.currency, ''), '. Thank you.'),
    'payment_received',
    'intent_created',
    now()
  );
end;
$$;

-- Attach trigger to payments
drop trigger if exists trg_enqueue_sms_on_payments on public.payments;
create trigger trg_enqueue_sms_on_payments
after insert or update on public.payments
for each row
execute function public.enqueue_sms_on_payment();

-- 10) Useful constraints / policies hints (commented)
-- Example: enable Row Level Security and create policies for authenticated users.
-- alter table public.students enable row level security;
-- create policy "Allow authenticated insert" on public.students
--   for insert using (auth.role() = 'authenticated') with check (auth.role() = 'authenticated');

-- End of consolidated schema
