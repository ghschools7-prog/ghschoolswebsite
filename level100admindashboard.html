<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Finance Admin - GH Technical University</title>

  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <!-- Chart.js for analytics -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Supabase SDK (use jsDelivr UMD build for better availability) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.js"></script>
  <script>
    // Quick runtime check to help diagnose network/CDN issues early
    if (typeof supabase === 'undefined') {
      console.error('Supabase client failed to load. Check network/DNS or CDN availability.');
    }

    async function deleteManualPayment(idOrPaymentId) {
      if (!idOrPaymentId) return showModalMessage('Payment id missing');
      const ok = await showConfirm('Delete this manual payment? This action cannot be undone.', 'Confirm Delete');
      if (!ok) return;

      try {
        // Try delete by primary id first
        let res = await sb.from('level100payments').delete().eq('id', idOrPaymentId).select();
        if (res.error || !res.data || res.data.length === 0) {
          // fallback: try by payment_id
          try {
            res = await sb.from('level100payments').delete().eq('payment_id', idOrPaymentId).select();
          } catch (e) { /* ignore */ }
        }

        if (res.error) {
          console.error('Delete failed', res.error);
          showModalMessage('Could not delete payment: ' + (res.error.message || res.error));
          return;
        }

        showModalMessage('Manual payment deleted');
        try { allPayments = await fetchAllPayments(); allStudents = await fetchAllStudents(); } catch(e){}
        loadManualPayments(); loadDashboardData();
      } catch (err) {
        console.error('deleteManualPayment error', err);
        showModalMessage('Error deleting payment. See console for details.');
      }
    }

    async function softDeleteStudent(studentId) {
      if (!studentId) return showModalMessage('Student ID missing');
      // Confirm intent first
      if (!(await showConfirm(`Soft-delete student ${studentId}? This will mark the student as deleted (soft-delete). Continue?`, 'Confirm Soft Delete'))) return;

      // Require typing the student id for safety
      try {
        const typed = window.prompt(`Type the student ID (${studentId}) to confirm soft-delete:`,'');
        if (!typed || (typed || '').trim() !== String(studentId).trim()) {
          showModalMessage('Confirmation text did not match. Aborting.');
          return;
        }
      } catch(e) { /* user cancelled prompt */ return; }

      try {
        const now = new Date().toISOString();
        // Try update by student_id first
        let upd = await sb.from('students').update({ deleted_at: now }).eq('student_id', studentId).select();
        if (upd.error || !upd.data || upd.data.length === 0) {
          // Try other possible columns
          try { upd = await sb.from('students').update({ deleted_at: now }).eq('admission_number', studentId).select(); } catch(e){}
        }
        if (upd.error || !upd.data || upd.data.length === 0) {
          // Try by numeric id
          try { upd = await sb.from('students').update({ deleted_at: now }).eq('id', studentId).select(); } catch(e){}
        }

        // If still nothing updated, try newstudents table (in case student is there)
        if (!upd || !upd.data || upd.data.length === 0) {
          try { upd = await sb.from('newstudents').update({ deleted_at: now }).eq('student_id', studentId).select(); } catch(e){}
        }

        if (upd && upd.error) {
          console.error('softDeleteStudent error', upd.error);
          showModalMessage('Could not soft-delete student: ' + (upd.error.message || upd.error));
          return;
        }

        if (!upd || !upd.data || upd.data.length === 0) {
          showModalMessage('No matching student row found to soft-delete.');
          return;
        }

        showModalMessage('Student marked deleted (soft-delete)');
        try { allStudents = await fetchAllStudents(); } catch(e){}
        try { loadManualPayments(); loadDashboardData(); } catch(e){}
      } catch (err) {
        console.error('softDeleteStudent error', err);
        showModalMessage('Error deleting student. See console for details.');
      }
    }
  </script>
  <!-- jsPDF for PDF receipts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    :root {
      --primary: #1e3a8a;
      --primary-light: #3b82f6;
      --primary-dark: #1e40af;
      --secondary: #0f766e;
      --accent: #f59e0b;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --light: #f8fafc;
      --dark: #1e293b;
      --gray: #64748b;
      --gray-light: #e2e8f0;
      --white: #ffffff;
      --sidebar-width: 260px;
      --sidebar-collapsed: 70px;
      --header-height: 70px;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --radius: 8px;
      --radius-lg: 12px;
      --sms: #1e90ff;
    }

    * { 
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f1f5f9;
      color: var(--dark);
      line-height: 1.6;
      overflow-x: auto; /* allow horizontal scrolling when content is wider than viewport */
    }

    .dashboard-container {
      display: flex;
      min-height: 100vh;
    }

    /* Allow horizontal scrolling on the main dashboard if content overflows */
    .dashboard-container {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    /* Sidebar */
    .sidebar {
      width: var(--sidebar-width);
      background: var(--primary);
      color: var(--white);
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-lg);
      z-index: 100;
      transition: all 0.3s ease;
      position: fixed;
      height: 100vh;
      overflow-y: auto;
    }

    .sidebar.collapsed {
      width: var(--sidebar-collapsed);
    }

    .sidebar-header {
      padding: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: var(--header-height);
    }

    .sidebar-header .logo {
      font-size: 1.25rem;
      font-weight: 700;
      letter-spacing: 0.5px;
      white-space: nowrap;
      overflow: hidden;
    }

    .sidebar.collapsed .logo {
      display: none;
    }

    .toggle-sidebar {
      background: none;
      border: none;
      color: var(--white);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
      transition: background 0.3s;
    }

    .toggle-sidebar:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .sidebar-nav {
      flex: 1;
      padding: 20px 0;
    }

    .nav-item {
      display: flex;
      align-items: center;
      padding: 12px 20px;
      color: rgba(255, 255, 255, 0.8);
      text-decoration: none;
      transition: all 0.3s;
      border-left: 4px solid transparent;
      white-space: nowrap;
      overflow: hidden;
    }

    .nav-item:hover, .nav-item.active {
      background: rgba(255, 255, 255, 0.1);
      color: var(--white);
      border-left-color: var(--accent);
    }

    .nav-item i {
      width: 24px;
      margin-right: 12px;
      text-align: center;
      font-size: 1.1rem;
    }

    .sidebar.collapsed .nav-item span {
      display: none;
    }

    .sidebar-footer {
      padding: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .admin-card {
      background: rgba(255, 255, 255, 0.1);
      border-radius: var(--radius);
      padding: 16px;
      margin-bottom: 16px;
    }

    .admin-card h4 {
      margin-bottom: 8px;
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .admin-card p {
      font-size: 0.85rem;
      margin-bottom: 4px;
      opacity: 0.8;
    }

    .sidebar.collapsed .admin-card {
      display: none;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-left: var(--sidebar-width);
      transition: margin-left 0.3s ease;
    }

    /* Prevent content from squashing too small; allow horizontal scroll to view full layout */
    .main-content {
      /* allow content to shrink to fit viewport; individual cards can set their own widths */
      min-width: 0;
    }

    .main-content.expanded {
      margin-left: var(--sidebar-collapsed);
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 24px;
      background: var(--white);
      box-shadow: var(--shadow);
      height: var(--header-height);
      z-index: 10;
      position: sticky;
      top: 0;
    }

    .page-info h1 {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--dark);
    }

    .page-info p {
      font-size: 0.875rem;
      color: var(--gray);
    }

    .top-bar-actions {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .search-bar {
      display: flex;
      align-items: center;
      background: var(--light);
      border-radius: 24px;
      padding: 8px 16px;
      width: 320px;
    }

    .search-bar input {
      border: none;
      background: transparent;
      padding: 8px;
      width: 100%;
      outline: none;
      font-size: 0.9rem;
    }

    .user-actions {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .user-actions i {
      font-size: 1.2rem;
      color: var(--gray);
      cursor: pointer;
      transition: color 0.3s;
    }

    .user-actions i:hover {
      color: var(--primary);
    }

    .user-profile {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }

    /* Dashboard Content */
    .dashboard-content {
      padding: 24px;
      flex: 1;
    }

    /* Stats Grid */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 24px;
      margin-bottom: 24px;
    }

    .stat-card {
      background: var(--white);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      padding: 24px;
      display: flex;
      align-items: center;
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-lg);
    }

    .stat-icon {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 16px;
      font-size: 1.5rem;
    }

    .stat-icon.primary {
      background: rgba(30, 58, 138, 0.1);
      color: var(--primary);
    }

    .stat-icon.success {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .stat-icon.warning {
      background: rgba(245, 158, 11, 0.1);
      color: var(--warning);
    }

    .stat-icon.danger {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }

    .stat-info h3 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .stat-info p {
      font-size: 0.9rem;
      color: var(--gray);
    }

    /* Content Grid */
    .content-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 24px;
      margin-bottom: 24px;
    }

    /* Announcements specific layout adjustments */
    #announcements-tab .card {
      max-width: 1100px;
      margin: 0 auto;
      width: calc(100% - 48px);
      box-sizing: border-box;
    }

    #announcements-tab .card-body {
      overflow: auto;
    }

    #announcements-tab .form-control[contenteditable], #announcementEditor {
      max-width: 100%;
      box-sizing: border-box;
      word-break: break-word;
    }

    /* When sidebar is collapsed ensure main content moves correctly and announcements stay visible */
    .sidebar.collapsed + .main-content,
    .main-content.expanded {
      margin-left: var(--sidebar-collapsed);
    }

    /* Small screen tweaks for announcements editor */
    @media (max-width: 1000px) {
      #announcements-tab .card { width: 100%; padding: 12px; }
      #announcements-tab .form-control[contenteditable], #announcementEditor { min-height: 120px; }
    }

    @media (max-width: 1200px) {
      .content-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Card Styles */
    .card {
      background: var(--white);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--gray-light);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card-header h2 {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--dark);
    }

    .card-actions {
      display: flex;
      gap: 12px;
    }

    .card-body {
      padding: 24px;
    }

    /* Tables */
    .table-responsive {
      overflow-x: auto;
    }

    /* Ensure long tables don't overflow the page — make them vertically scrollable */
    .card-body .table-responsive {
      max-height: 55vh;
      overflow-y: auto;
    }

    /* Student info / payment panels should scroll if content is large */
    #studentInfoPanel, #studentPaymentsPanel, .receipt-preview, .student-details, .payment-info {
      max-height: 60vh;
      overflow-y: auto;
    }

    .table {
      width: 100%;
      border-collapse: collapse;
    }

    .table th, .table td {
      padding: 16px 24px;
      text-align: left;
      border-bottom: 1px solid var(--gray-light);
    }

    .table th {
      background: var(--light);
      font-weight: 600;
      color: var(--dark);
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .table tbody tr:hover {
      background: rgba(0, 0, 0, 0.02);
    }

    /* Status badges */
    .status-badge {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-pending {
      background: rgba(245, 158, 11, 0.1);
      color: var(--warning);
    }

    .status-approved {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .status-rejected {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }

    .status-paid {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .status-unpaid {
      background: rgba(100, 116, 139, 0.1);
      color: var(--gray);
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 20px;
      background: var(--primary);
      color: var(--white);
      border: none;
      border-radius: var(--radius);
      font-weight: 600;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9rem;
    }

    .btn:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
    }

    .btn-sm {
      padding: 6px 12px;
      font-size: 0.8rem;
    }

    .btn-success {
      background: var(--success);
    }

    .btn-success:hover {
      background: #0da271;
    }

    .btn-warning {
      background: var(--warning);
    }

    .btn-warning:hover {
      background: #d97706;
    }

    .btn-danger {
      background: var(--danger);
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .btn-secondary {
      background: var(--gray-light);
      color: var(--dark);
    }

    .btn-secondary:hover {
      background: var(--gray);
    }

    .btn-sms {
      background: var(--sms);
    }

    /* Action buttons grouping for tables */
    .action-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .action-group .btn { margin: 0; }

    .btn-sms:hover {
      background: #1666c8;
    }

    /* Forms */
    .form-group {
      margin-bottom: 20px;
    }

    .form-row {
      display: flex;
      gap: 20px;
    }

    .form-col {
      flex: 1;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--dark);
    }

    .form-control {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--gray-light);
      border-radius: var(--radius);
      font-size: 1rem;
      transition: border 0.3s;
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(30, 58, 138, 0.1);
    }

    .form-select {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%231e293b'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      appearance: none;
      padding-right: 40px;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: var(--white);
      border-radius: 0;
      box-shadow: none;
      width: 100%;
      height: 100%;
      max-width: none;
      max-height: none;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: hidden; /* body scrolls */
    }

    .modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--gray-light);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      margin: 0;
      color: var(--primary);
      font-size: 1.5rem;
    }

    /* All Data: compact table and sticky header for better scanning */
    .compact-table th, .compact-table td { padding: 10px 12px; font-size: 0.92rem; }
    .compact-table thead th { position: sticky; top: 96px; background: var(--white); z-index: 30; border-bottom: 2px solid var(--gray-light); }
    .compact-table tbody tr td { vertical-align: middle; }
    .compact-table tbody tr:nth-child(odd) { background: rgba(0,0,0,0.02); }
    .all-data-toolbar .form-control { min-width: 140px; }
    .all-data-toolbar .btn { padding: 6px 10px; font-size: 0.9rem; }
    .all-data-toolbar input.form-control { padding: 8px 10px; }
    .table-responsive { max-height: calc(100vh - 320px); overflow: auto; }
    .all-action-btn { padding:6px 8px; font-size:0.85rem; margin:0 2px; }

    .close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: var(--gray);
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: background 0.3s;
    }

    .close-btn:hover {
      background: var(--gray-light);
    }

    .modal-body {
      padding: 24px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      /* Leave room for header + footer */
      max-height: calc(100vh - 120px);
    }

    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--gray-light);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid var(--gray-light);
      margin-bottom: 24px;
    }

    .tab {
      padding: 12px 24px;
      cursor: pointer;
      font-weight: 500;
      border-bottom: 3px solid transparent;
      transition: all 0.3s;
      color: var(--gray);
    }

    .tab.active {
      border-bottom-color: var(--primary);
      color: var(--primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Charts */
    .chart-container {
      background: var(--white);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      padding: 24px;
      margin-bottom: 24px;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .chart-header h3 {
      margin: 0;
      color: var(--primary);
    }

    .chart-actions {
      display: flex;
      gap: 12px;
    }

    .chart-wrapper {
      position: relative;
      height: 300px;
    }

    /* Payment details */
    .payment-details {
      background: var(--light);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 20px;
    }

    .payment-details h4 {
      margin-bottom: 16px;
      color: var(--primary);
    }

    .payment-info {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
    }

    .payment-info-item {
      display: flex;
      flex-direction: column;
    }

    .payment-info-label {
      font-size: 0.85rem;
      color: var(--gray);
      margin-bottom: 4px;
    }

    .payment-info-value {
      font-weight: 500;
    }

    /* Student info */
    .student-info {
      background: var(--light);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 20px;
    }

    .student-info h4 {
      margin-bottom: 16px;
      color: var(--primary);
    }

    .student-details {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
    }

    .student-detail-item {
      display: flex;
      flex-direction: column;
    }

    .student-detail-label {
      font-size: 0.85rem;
      color: var(--gray);
      margin-bottom: 4px;
    }

    .student-detail-value {
      font-weight: 500;
    }

    /* Receipt preview */
    .receipt-preview {
      border: 1px solid var(--gray-light);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }

    .receipt-preview img {
      max-width: 100%;
      max-height: 400px;
      border-radius: var(--radius);
    }

    .receipt-placeholder {
      padding: 40px;
      background: var(--gray-light);
      border-radius: var(--radius);
      color: var(--gray);
    }

    /* Loading spinner */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid var(--white);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Manual Payment Form */
    .manual-payment-form {
      background: var(--white);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      padding: 24px;
      margin-bottom: 24px;
    }

    .form-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: var(--primary);
    }

    /* SMS Message Preview */
    .sms-preview {
      background: #eef6ff;
      border-radius: 12px;
      padding: 16px;
      margin: 16px 0;
      position: relative;
      max-width: 80%;
      border: 1px solid #e0e0e0;
    }

    .sms-preview::before {
      content: '';
      position: absolute;
      top: 10px;
      left: -8px;
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-right: 8px solid #eef6ff;
    }

    .sms-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }

    .sms-logo {
      color: var(--sms);
      font-size: 1.2rem;
      margin-right: 8px;
    }

    .sms-sender {
      font-weight: 600;
      color: var(--dark);
    }

    .sms-time {
      font-size: 0.75rem;
      color: var(--gray);
      margin-left: auto;
    }

    .sms-message {
      color: var(--dark);
      line-height: 1.4;
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }
    }

    @media (max-width: 768px) {
      .sidebar {
        transform: translateX(-100%);
      }

      /* On small screens give tables more room and ensure scrollability */
      .card-body .table-responsive { max-height: 40vh; }

      .sidebar.mobile-open {
        transform: translateX(0);
      }

      .main-content {
        margin-left: 0;
      }

      .main-content.expanded {
        margin-left: 0;
      }

      .top-bar {
        padding: 0 16px;
      }

      .search-bar {
        width: 200px;
      }

      .dashboard-content {
        padding: 16px;
      }

      .form-row {
        flex-direction: column;
        gap: 0;
      }

      .sms-preview {
        max-width: 90%;
      }
    }

    @media (max-width: 576px) {
      .stats-grid {
        grid-template-columns: 1fr;
      }

      .top-bar {
        flex-wrap: wrap;
        height: auto;
        padding: 16px;
      }

      .search-bar {
        width: 100%;
        order: 3;
        margin-top: 16px;
      }

      .user-actions {
        margin-left: auto;
      }
    }

    /* Mobile Toggle */
    .mobile-toggle {
      display: none;
      background: none;
      border: none;
      font-size: 1.5rem;
      color: var(--primary);
      cursor: pointer;
      margin-right: 16px;
    }

    @media (max-width: 768px) {
      .mobile-toggle {
        display: block;
      }
    }

    /* Student Eligibility Status */
    .eligibility-status {
      padding: 12px;
      border-radius: var(--radius);
      margin: 16px 0;
      font-weight: 600;
    }

    .eligibility-pending {
      background: rgba(245, 158, 11, 0.1);
      color: var(--warning);
      border-left: 4px solid var(--warning);
    }

    .eligibility-approved {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
      border-left: 4px solid var(--success);
    }

    .eligibility-rejected {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
      border-left: 4px solid var(--danger);
    }
  </style>
</head>
<body>

  <div class="dashboard-container">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="logo">GH TECH FINANCE</div>
        <button class="toggle-sidebar" onclick="toggleSidebar()">
          <i class="fas fa-bars"></i>
        </button>
      </div>

      <nav class="sidebar-nav">
        <a href="#" class="nav-item active" data-tab="dashboard">
          <i class="fas fa-tachometer-alt"></i>
          <span>Dashboard</span>
        </a>
        <a href="#" class="nav-item" data-tab="manual-payments">
          <i class="fas fa-hand-holding-usd"></i>
          <span>Collect Fees</span>
        </a>
        <a href="#" class="nav-item" data-tab="payment-review">
          <i class="fas fa-money-check-alt"></i>
          <span>Payment Review</span>
        </a>
        <a href="#" class="nav-item" data-tab="students">
          <i class="fas fa-user-graduate"></i>
          <span>Student Accounts</span>
        </a>
        <a href="#" class="nav-item" data-tab="reports">
          <i class="fas fa-chart-bar"></i>
          <span>Financial Reports</span>
        </a>
        <a href="#" class="nav-item" data-tab="sms">
          <i class="fas fa-comment"></i>
          <span>SMS Notifications</span>
        </a>
        <a href="#" class="nav-item" data-tab="announcements">
          <i class="fas fa-bullhorn"></i>
          <span>Announcements</span>
        </a>
        <a href="#" class="nav-item" onclick="confirmLogout()">
          <i class="fas fa-sign-out-alt"></i>
          <span>Logout</span>
        </a>
      </nav>

      <div class="sidebar-footer">
        <div class="admin-card">
          <h4><i class="fas fa-user-shield"></i> Finance Admin</h4>
          <p><strong>Name:</strong> <span id="adminName">Mr. Finance Officer</span></p>
          <p><strong>Role:</strong> <span id="adminRole">Chief Accountant</span></p>
          <p><strong>Last Login:</strong> <span id="lastLogin">Today, 09:42 AM</span></p>
        </div>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content" id="mainContent">
      <header class="top-bar">
        <div class="page-info">
          <h1 id="pageTitle">Finance Dashboard</h1>
          <p id="pageSubtitle">Payment management and financial oversight</p>
        </div>
        
        <div class="top-bar-actions">
          <div class="search-bar">
            <i class="fas fa-search"></i>
            <input type="text" placeholder="Search students, payments..." aria-label="Search" id="searchInput">
          </div>
          <button class="btn btn-sm" style="margin-left:8px;" onclick="openAllDataModal()">
            <i class="fas fa-database"></i> Load All Data
          </button>
          
          <div class="user-actions">
            <i class="fas fa-bell" title="Notifications"></i>
            <i class="fas fa-envelope" title="Messages"></i>
            <div class="user-profile">
              <div class="user-avatar" id="userAvatar">F</div>
            </div>
          </div>
        </div>
      </header>

      <div class="dashboard-content">
        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboard-tab">
          <!-- Stats Cards -->
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-icon primary">
                <i class="fas fa-money-bill-wave"></i>
              </div>
              <div class="stat-info">
                <h3 id="totalRevenue">GHS 0.00</h3>
                <p>Total Revenue</p>
              </div>
            </div>

            <div class="stat-card">
              <div class="stat-icon success">
                <i class="fas fa-check-circle"></i>
              </div>
              <div class="stat-info">
                <h3 id="approvedPayments">0</h3>
                <p>Approved Payments</p>
              </div>
            </div>

            <div class="stat-card">
              <div class="stat-icon warning">
                <i class="fas fa-clock"></i>
              </div>
              <div class="stat-info">
                <h3 id="pendingReview">0</h3>
                <p>Pending Review</p>
              </div>
            </div>

            <div class="stat-card">
              <div class="stat-icon danger">
                <i class="fas fa-exclamation-circle"></i>
              </div>
              <div class="stat-info">
                <h3 id="overduePayments">0</h3>
                <p>Overdue Payments</p>
              </div>
            </div>
          </div>

          <!-- Content Grid -->
          <div class="content-grid">
            <!-- Left Column -->
            <div class="left-column">
              <!-- Recent Payments -->
              <div class="card">
                <div class="card-header">
                  <h2>Recent Payments</h2>
                  <div class="card-actions">
                    <button class="btn btn-sm" onclick="loadDashboardData()">
                      <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                  </div>
                </div>
                <div class="card-body">
                  <div class="table-responsive">
                    <table class="table">
                      <thead>
                        <tr>
                          <th>Student</th>
                          <th>Type</th>
                          <th>Amount</th>
                          <th>Date</th>
                          <th>Status</th>
                        </tr>
                      </thead>
                      <tbody id="recentPaymentsTable">
                        <!-- Recent payments will be loaded here -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <!-- Payment Analytics -->
              <div class="chart-container">
                <div class="chart-header">
                  <h3>Payment Analytics</h3>
                  <div class="chart-actions">
                    <select class="form-control form-select" style="width: auto;" onchange="updateAnalytics()">
                      <option value="week">This Week</option>
                      <option value="month" selected>This Month</option>
                      <option value="quarter">This Quarter</option>
                    </select>
                  </div>
                </div>
                <div class="chart-wrapper">
                  <canvas id="paymentAnalyticsChart"></canvas>
                </div>
              </div>
            </div>

            <!-- Right Column -->
            <div class="right-column">
              <!-- Quick Actions -->
              <div class="card">
                <div class="card-header">
                  <h2>Quick Actions</h2>
                </div>
                <div class="card-body">
                  <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button class="btn" onclick="openTab('manual-payments')">
                      <i class="fas fa-hand-holding-usd"></i> Collect Manual Payment
                    </button>
                    <button class="btn btn-success" onclick="openTab('payment-review')">
                      <i class="fas fa-check-circle"></i> Review Payments
                    </button>
                    <button class="btn btn-secondary" onclick="openTab('students')">
                      <i class="fas fa-user-graduate"></i> Student Accounts
                    </button>
                    <button class="btn btn-warning" onclick="openTab('reports')">
                      <i class="fas fa-file-invoice-dollar"></i> Generate Report
                    </button>
                  </div>
                </div>
              </div>

              <!-- Pending Approvals removed (approval workflow disabled) -->
              <!-- Pending approvals UI intentionally removed to disable approval workflow -->
            </div>
          </div>
        </div>

        <!-- Manual Payments Tab -->
        <div class="tab-content" id="manual-payments-tab">
          <div class="manual-payment-form">
            <h2 class="form-title">Collect Manual Payment</h2>
            <form id="manualPaymentForm">
              <div class="form-row">
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="studentSearch">Search Student</label>
                    <input type="text" class="form-control" id="studentSearch" placeholder="Enter student name or ID">
                    <div id="studentSearchResults" style="margin-top: 8px; display: none;"></div>

                    <!-- Student info panel populated from Supabase -->
                    <div id="studentInfoPanel" style="margin-top:12px; display:none; background:var(--white); padding:12px; border:1px solid var(--gray-light); border-radius:8px;">
                      <div id="studentInfoContent">
                        <!-- Filled dynamically -->
                      </div>
                      <div style="margin-top:8px; display:flex; gap:8px;">
                        <button type="button" class="btn btn-secondary btn-sm" onclick="clearSelectedStudent()">Clear</button>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label">Payment Type(s) — select one or more</label>
                    <div style="display:flex;flex-direction:column;gap:6px;padding:8px;border:1px solid var(--gray-light);border-radius:8px;background:var(--white);">
                      <label style="font-weight:500;"><input type="checkbox" class="fee-checkbox" value="admission" /> Admission Fee (GHS 800)</label>
                      <label style="font-weight:500;"><input type="checkbox" class="fee-checkbox" value="tuition" /> Tuition (80%) (GHS 2,040)</label>
                      <label style="font-weight:500;"><input type="checkbox" class="fee-checkbox" value="tuition100" /> Tuition (100%) (GHS 2,550)</label>
                      <label style="font-weight:500;"><input type="checkbox" class="fee-checkbox" value="src" /> SRC Dues (GHS 50)</label>
                      <label style="font-weight:500;"><input type="checkbox" class="fee-checkbox" value="departmental" /> Departmental Dues (GHS 50)</label>
                      <label style="font-weight:500;"><input type="checkbox" class="fee-checkbox" value="medical" /> Medical Dues (GHS 80)</label>
                      <label style="font-weight:500;"><input type="checkbox" class="fee-checkbox" value="other" /> Other (specify amount below)</label>
                      <label style="font-size:0.9rem;color:var(--gray);"><input type="checkbox" id="selectAllFees" /> Select All</label>
                    </div>
                    <small id="feesHelp" style="display:block;margin-top:6px;color:var(--gray);">Selecting fees will auto-fill the Amount field. You can edit the total before recording; amounts will be split proportionally across selected fees.</small>
                  </div>
                </div>
              </div>

              <div class="form-row">
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="amount">Amount (GHS)</label>
                    <input type="number" class="form-control" id="amount" placeholder="0.00" step="0.01" min="0">
                  </div>
                </div>
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="paymentDate">Payment Date</label>
                    <input type="date" class="form-control" id="paymentDate">
                  </div>
                </div>
              </div>

              <div class="form-row">
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="receiptNumber">Receipt Number (optional)</label>
                    <input type="text" class="form-control" id="receiptNumber" placeholder="Enter receipt number (leave empty to auto-generate)">
                  </div>
                </div>
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="paymentMethod">Payment Method</label>
                    <select class="form-control form-select" id="paymentMethod">
                      <option value="cash">Cash</option>
                      <option value="bank">Bank Transfer</option>
                      <option value="mobile">Mobile Money</option>
                      <option value="cheque">Cheque</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="form-group">
                <label class="form-label" for="paymentNotes">Payment Notes</label>
                <textarea class="form-control" id="paymentNotes" rows="3" placeholder="Add any additional notes about this payment..."></textarea>
              </div>

              <div class="form-group">
                <label class="form-label">Receipt Handling</label>
                <div style="padding:12px; border:1px dashed var(--gray-light); border-radius:6px; background:var(--white); color:var(--gray);">
                  Receipts are recorded automatically when admin records payments. You can optionally enter a custom <strong>Receipt Number</strong> above — if left empty the system will auto-generate a unique receipt/transaction reference.
                </div>
              </div>

              <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button type="button" class="btn btn-secondary" onclick="resetManualPaymentForm()">
                  <i class="fas fa-times"></i> Cancel
                </button>
                <button type="submit" class="btn">
                  <i class="fas fa-save"></i> Record Payment
                </button>
                <button type="button" id="addToBatchBtn" class="btn btn-sm btn-secondary" style="margin-left:8px;" onclick="addToBatch()">
                  <i class="fas fa-layer-group"></i> Add To Batch
                </button>
                <button type="button" id="recordBatchBtn" class="btn btn-success btn-sm" style="margin-left:8px; display:none;" onclick="processBatchPayments()">
                  <i class="fas fa-save"></i> Record Batch Payments
                </button>
                <button type="button" id="clearBatchBtn" class="btn btn-danger btn-sm" style="margin-left:8px; display:none;" onclick="clearBatch()">
                  <i class="fas fa-trash"></i> Clear Batch
                </button>
              </div>
            </form>
            
            <!-- Batch list (hidden until items added) -->
            <div id="manualPaymentBatch" style="margin-top:16px; display:none;">
              <h3 style="margin-bottom:8px;">Batch Payments</h3>
              <div class="table-responsive">
                <table class="table" id="manualPaymentBatchTable">
                  <thead>
                    <tr>
                      <th>#</th>
                      <th>Student ID</th>
                      <th>Student Name</th>
                      <th>Fee Type</th>
                      <th>Amount</th>
                      <th>Receipt No.</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
              <div style="display:flex; gap:8px; margin-top:8px;">
                <button class="btn btn-success" onclick="processBatchPayments()">Record Batch Payments</button>
                <button class="btn btn-secondary" onclick="clearBatch()">Clear Batch</button>
              </div>
            </div>
          </div>

          <!-- Recent Manual Payments -->
          <div class="card">
            <div class="card-header" style="display:flex;align-items:center;gap:12px;">
              <div style="flex:1;display:flex;align-items:center;gap:12px;">
                <h2 style="margin:0;">Recent Manual Payments</h2>
                <div style="display:flex;gap:8px;align-items:center;">
                  <input id="manualPaymentsSearch" class="form-control" placeholder="Search student name / ID / receipt" style="width:260px;padding:8px;" />
                  <button id="manualPaymentsClear" class="btn btn-sm btn-secondary" onclick="(function(){ const el=document.getElementById('manualPaymentsSearch'); if(el) el.value=''; loadManualPayments(); })()">Clear</button>
                </div>
              </div>
              <div class="card-actions">
                <button class="btn btn-sm" onclick="loadManualPayments()">
                  <i class="fas fa-sync-alt"></i> Refresh
                </button>
              </div>
            </div>
            <div class="card-body">
              <div class="table-responsive">
                <table class="table">
                  <thead>
                    <tr>
                      <th>Student</th>
                      <th>Type</th>
                      <th>Amount</th>
                      <th>Date</th>
                      <th>Receipt No.</th>
                      <th>Status</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="manualPaymentsTable">
                    <!-- Manual payments will be loaded here -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <!-- Payment Review Tab -->
        <div class="tab-content" id="payment-review-tab">
          <div class="card">
            <div class="card-header">
              <h2>Payment Review & Approval</h2>
              <div class="card-actions">
                <button class="btn btn-sm" onclick="loadPaymentReviewData()">
                  <i class="fas fa-sync-alt"></i> Refresh
                </button>
                <button class="btn btn-sm btn-secondary" onclick="exportPaymentData()">
                  <i class="fas fa-download"></i> Export
                </button>
              </div>
            </div>
            <div class="card-body">
              <div class="tabs">
                <div class="tab active" data-subtab="approved">Approved</div>
                <div class="tab" data-subtab="rejected">Rejected</div>
              </div>

              <!-- Pending approvals removed from UI (approvals disabled) -->
              <div class="tab-content active" id="approved-subtab">
                <div class="table-responsive">
                  <table class="table">
                    <thead>
                      <tr>
                        <th>Student</th>
                        <th>Payment Type</th>
                        <th>Amount</th>
                        <th>Date</th>
                        <th>Approved By</th>
                        <th>Actions</th>
                      </tr>
                    </thead>
                    <tbody id="approvedPaymentsTable">
                      <!-- Approved payments will be loaded here -->
                    </tbody>
                  </table>
                </div>
              </div>

              <div class="tab-content" id="rejected-subtab">
                <div class="table-responsive">
                  <table class="table">
                    <thead>
                      <tr>
                        <th>Student</th>
                        <th>Payment Type</th>
                        <th>Amount</th>
                        <th>Date</th>
                        <th>Reason</th>
                        <th>Actions</th>
                      </tr>
                    </thead>
                    <tbody id="rejectedPaymentsTable">
                      <!-- Rejected payments will be loaded here -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Student Accounts Tab -->
        <div class="tab-content" id="students-tab">
          <div class="card">
            <div class="card-header">
              <h2>Student Accounts</h2>
              <div style="display:flex;align-items:center;gap:8px;">
                <input id="studentAccountSearchId" type="text" class="form-control" placeholder="Enter Student ID or Admission No." style="width:220px;padding:8px;margin-right:6px;" />
                <select id="studentLevelFilter" class="form-control" style="padding:6px;min-width:120px;margin-right:6px;"><option value="">All Levels</option></select>
                <select id="studentDepartmentFilter" class="form-control" style="padding:6px;min-width:160px;margin-right:6px;"><option value="">All Departments</option></select>
                <select id="studentProgramFilter" class="form-control" style="padding:6px;min-width:160px;margin-right:6px;"><option value="">All Programs</option></select>
                <button class="btn btn-sm" onclick="adminSearchStudentById()">
                  <i class="fas fa-search"></i> Search
                </button>
                <div class="card-actions" style="margin-left:auto;">
                  <button class="btn btn-sm" onclick="loadStudents()">
                    <i class="fas fa-sync-alt"></i> Refresh
                  </button>
                  <button class="btn btn-sm btn-secondary" onclick="exportStudentData()">
                    <i class="fas fa-download"></i> Export
                  </button>
                </div>
              </div>
            </div>
            <div class="card-body">
              <div class="table-responsive">
                <table class="table">
                  <thead>
                    <tr>
                      <th>Student ID</th>
                      <th>Name</th>
                      <th>Program</th>
                      <th>Admission Fee</th>
                      <th>Tuition (80%)</th>
                      <th>Other Fees</th>
                      <th>Registration</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="studentsTable">
                    <!-- Students will be loaded here -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <!-- Financial Reports Tab -->
        <div class="tab-content" id="reports-tab">
          <div class="card">
            <div class="card-header">
              <h2>Financial Reports</h2>
              <div class="card-actions">
                <button class="btn btn-sm" onclick="generateReport()">
                  <i class="fas fa-file-pdf"></i> Generate PDF
                </button>
                <button class="btn btn-sm btn-secondary" onclick="exportReportData()">
                  <i class="fas fa-file-excel"></i> Export Excel
                </button>
              </div>
            </div>
            <div class="card-body">
              <div class="form-row">
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="reportType">Report Type</label>
                    <select class="form-control form-select" id="reportType">
                      <option value="payment-summary">Payment Summary</option>
                      <option value="revenue">Revenue Report</option>
                      <option value="student-payments">Student Payments</option>
                      <option value="outstanding">Outstanding Payments</option>
                    </select>
                  </div>
                </div>
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="reportPeriod">Period</label>
                    <select class="form-control form-select" id="reportPeriod">
                      <option value="today">Today</option>
                      <option value="week">This Week</option>
                      <option value="month" selected>This Month</option>
                      <option value="quarter">This Quarter</option>
                      <option value="year">This Year</option>
                      <option value="custom">Custom Range</option>
                    </select>
                  </div>
                </div>
                <div class="form-col">
                  <div class="form-group">
                    <label class="form-label" for="reportFormat">Format</label>
                    <select class="form-control form-select" id="reportFormat">
                      <option value="pdf">PDF</option>
                      <option value="excel">Excel</option>
                      <option value="csv">CSV</option>
                    </select>
                  </div>
                </div>
              </div>

              <div id="customDateRange" style="display: none; margin-top: 20px;">
                <div class="form-row">
                  <div class="form-col">
                    <div class="form-group">
                      <label class="form-label" for="startDate">Start Date</label>
                      <input type="date" class="form-control" id="startDate">
                    </div>
                  </div>
                  <div class="form-col">
                    <div class="form-group">
                      <label class="form-label" for="endDate">End Date</label>
                      <input type="date" class="form-control" id="endDate">
                    </div>
                  </div>
                </div>
              </div>

              <!-- Report Preview -->
              <div id="reportPreview" style="margin-top: 24px;">
                <!-- Report preview will be displayed here -->
              </div>
            </div>
          </div>
        </div>

        <!-- SMS Notifications Tab (replaces legacy notifications tab) -->
        <div class="tab-content" id="sms-tab">
          <div class="card">
            <div class="card-header">
              <h2>SMS Notifications</h2>
              <div class="card-actions">
                <button class="btn btn-sm" onclick="loadSmsHistory()">
                  <i class="fas fa-sync-alt"></i> Refresh
                </button>
              </div>
            </div>
            <div class="card-body">
              <div class="form-group">
                <label class="form-label" for="smsRecipient">Recipient</label>
                <select class="form-control form-select" id="smsRecipient">
                  <option value="all">All Students</option>
                  <option value="pending">Students with Pending Payments</option>
                  <option value="approved">Students with Approved Payments</option>
                  <option value="specific">Specific Student</option>
                </select>
              </div>

              <div id="specificStudent" style="display: none; margin-top: 16px;">
                <div class="form-group">
                  <label class="form-label" for="studentSelect">Select Student</label>
                  <select class="form-control form-select" id="studentSelect">
                    <option value="">Select a student</option>
                    <!-- Student options will be loaded here -->
                  </select>
                </div>
              </div>

              <div class="form-group">
                <label class="form-label" for="smsTemplate">Message Template</label>
                <select class="form-control form-select" id="smsTemplate">
                  <option value="custom">Custom Message</option>
                  <option value="payment-approved">Payment Approved</option>
                  <option value="payment-received">Payment Received</option>
                  <option value="registration-eligible">Registration Eligible</option>
                  <option value="payment-reminder">Payment Reminder</option>
                </select>
              </div>

              <div class="form-group">
                <label class="form-label" for="smsMessage">Message</label>
                <textarea class="form-control" id="smsMessage" rows="5" placeholder="Type your message here..."></textarea>
                <div style="display: flex; justify-content: space-between; margin-top: 8px;">
                  <small style="color: var(--gray);">Character count: <span id="charCount">0</span>/320</small>
                </div>
              </div>

              <!-- SMS Message Preview -->
              <div class="sms-preview" id="smsPreview">
                <div class="sms-header">
                  <i class="fas fa-comment sms-logo"></i>
                  <span class="sms-sender">GH TECHNICAL UNIVERSITY</span>
                  <span class="sms-time" id="previewTime">Now</span>
                </div>
                <div class="sms-message" id="previewMessage">
                  Your message will appear here...
                </div>
              </div>

              <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button type="button" class="btn btn-secondary" onclick="previewSms()">
                  <i class="fas fa-eye"></i> Preview
                </button>
                <button type="button" class="btn btn-sms" onclick="sendSms()">
                  <i class="fas fa-comment"></i> Send via SMS
                </button>
              </div>

              <!-- SMS History -->
              <div style="margin-top: 32px;">
                <h3 style="margin-bottom: 16px;">SMS History</h3>
                <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px;">
                  <div style="font-size:0.95rem;color:var(--gray);">Total SMS: <span id="smsTotalCount">0</span></div>
                  <div style="font-size:0.95rem;color:var(--gray);">Total Sent (last 50): <span id="smsTotalSent">0</span></div>
                  <div style="margin-left:auto;display:flex;gap:8px;">
                    <button class="btn btn-sm" onclick="exportSmsCsv()"><i class="fas fa-file-csv"></i> Export CSV</button>
                    <button class="btn btn-sm" onclick="exportSmsPdf()"><i class="fas fa-file-pdf"></i> Export PDF</button>
                  </div>
                </div>
                <div id="smsHistory">
                  <!-- SMS history will be loaded here -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

        <!-- Announcements Tab -->
        <div class="tab-content" id="announcements-tab">
          <div class="card">
            <div class="card-header">
              <h2>Announcements</h2>
              <div class="card-actions">
                <button class="btn btn-sm" onclick="loadAnnouncementsAdmin()">
                  <i class="fas fa-sync-alt"></i> Refresh
                </button>
              </div>
            </div>
                <div class="card-body">
              <div style="display:grid;gap:12px;">
                <div class="form-group">
                  <label class="form-label">Title</label>
                  <input id="announcementTitle" class="form-control" placeholder="Short announcement title" />
                </div>

                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:center;">
                  <div class="form-group">
                    <label class="form-label">Send (optional)</label>
                    <input id="announcementSchedule" type="datetime-local" class="form-control" />
                  </div>
                  <div class="form-group">
                    <label class="form-label">Priority</label>
                    <select id="announcementPriority" class="form-control form-select">
                      <option value="normal">Normal</option>
                      <option value="high">High</option>
                      <option value="urgent">Urgent</option>
                    </select>
                  </div>
                </div>

                <div style="display:flex;gap:12px;align-items:center;">
                  <label style="display:flex;align-items:center;gap:8px;">
                    <input type="checkbox" id="announcementChannelInApp" checked /> In-app
                  </label>
                  <label style="display:flex;align-items:center;gap:8px;">
                    <input type="checkbox" id="announcementChannelSms" /> SMS
                  </label>
                  <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
                    <button class="btn btn-sm" id="saveDraftBtn">Save Draft</button>
                    <button class="btn btn-sm" id="saveTemplateBtn">Save Template</button>
                  </div>
                </div>

                <div id="specificAudienceRow" style="display:none;margin-top:8px;">
                  <label class="form-label">Specific recipients (comma-separated student IDs or emails)</label>
                  <input id="announcementSpecificList" class="form-control" placeholder="e.g. STU123, STU456 or email1@example.com" />
                </div>

                <div class="form-group">
                  <label class="form-label">Message</label>
                  <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;">
                    <div style="display:flex;gap:6px;">
                      <button type="button" class="btn btn-sm" onclick="execAnnCmd('bold')"><b>B</b></button>
                      <button type="button" class="btn btn-sm" onclick="execAnnCmd('italic')"><i>I</i></button>
                      <button type="button" class="btn btn-sm" onclick="execAnnCmd('underline')"><u>U</u></button>
                    </div>
                    <div style="margin-left:auto;display:flex;gap:6px;align-items:center;">
                      <button type="button" class="btn btn-sm" id="emojiBtn">😊</button>
                      <select id="announcementTarget" class="form-control form-select" style="width:auto;">
                        <option value="all">All Students</option>
                        <option value="level100">Level 100</option>
                        <option value="level200">Level 200</option>
                        <option value="specific">Specific (select below)</option>
                      </select>
                    </div>
                  </div>

                  <div id="announcementEditor" contenteditable="true" class="form-control" style="min-height:140px;overflow:auto;border:1px solid var(--gray-light);padding:12px;border-radius:8px;background:var(--white);"></div>
                  <div id="emojiMenu" style="display:none;padding:8px;border:1px solid var(--gray-light);background:var(--white);border-radius:8px;margin-top:8px;">
                    <!-- small emoji palette -->
                    <button type="button" class="btn btn-sm" onclick="insertEmoji('😀')">😀</button>
                    <button type="button" class="btn btn-sm" onclick="insertEmoji('🎉')">🎉</button>
                    <button type="button" class="btn btn-sm" onclick="insertEmoji('📢')">📢</button>
                    <button type="button" class="btn btn-sm" onclick="insertEmoji('📣')">📣</button>
                    <button type="button" class="btn btn-sm" onclick="insertEmoji('📌')">📌</button>
                    <button type="button" class="btn btn-sm" onclick="insertEmoji('❤️')">❤️</button>
                    <button type="button" class="btn btn-sm" onclick="insertEmoji('👍')">👍</button>
                  </div>
                </div>

                <div style="display:flex;gap:12px;">
                  <button class="btn btn-success" onclick="sendAnnouncement()"><i class="fas fa-paper-plane"></i> Send Announcement</button>
                  <button class="btn btn-secondary" onclick="previewAnnouncement()"><i class="fas fa-eye"></i> Preview</button>
                </div>

                <hr />

                <h3>Previous Announcements</h3>
                <div class="table-responsive">
                  <table class="table">
                    <thead>
                      <tr><th>When</th><th>Title</th><th>Message</th><th>Author</th><th>Actions</th></tr>
                    </thead>
                    <tbody id="announcementsList">
                      <!-- loaded dynamically -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>

  <!-- Payment Detail Modal -->
  <div id="paymentDetailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Payment Details</h2>
        <button class="close-btn" onclick="closeModal('paymentDetailModal')">&times;</button>
      </div>
      <div class="modal-body">
        <div class="student-info">
          <h4>Student Information</h4>
          <div class="student-details" id="studentDetails">
            <!-- Student details will be loaded here -->
          </div>
        </div>

        <div class="payment-details">
          <h4>Payment Information</h4>
          <div class="payment-info" id="paymentDetails">
            <!-- Payment details will be loaded here -->
          </div>
        </div>

        <!-- Student Payment Eligibility Status -->
        <div id="studentEligibilityStatus" class="eligibility-status" style="display: none;">
          <!-- Will be populated by JavaScript -->
        </div>

        <div class="receipt-preview" id="receiptPreview">
          <!-- Receipt preview will be loaded here -->
        </div>

        <div class="payment-details">
          <h4>Student Payments</h4>
          <div class="payment-info" id="paymentDetailStudentPayments">
            <!-- Full payment list for this student will be rendered here -->
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="adminNotes">Admin Notes</label>
          <textarea class="form-control" id="adminNotes" rows="3" placeholder="Add notes about this payment..."></textarea>
        </div>

        <div class="form-group">
          <label class="form-label">Send SMS Notification</label>
          <div style="display: flex; align-items: center; gap: 12px;">
            <input type="checkbox" id="sendSms" checked>
            <label for="sendSms">Notify student via SMS when approved</label>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('paymentDetailModal')">Close</button>
        <button class="btn btn-danger" id="rejectPaymentBtn" onclick="approvalsDisabled()">Reject Payment</button>
      </div>
    </div>
  </div>

  <!-- All Data Modal (Payments + Students) -->
  <div id="allDataModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div style="display:flex;flex-direction:column;gap:6px;min-width:0;">
          <h2 style="margin:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">All Payments & Students</h2>
          <div style="font-size:0.85rem;color:var(--gray);">Joined recent rows from `payments` + `level100payments` and `students` tables</div>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <div id="allDataCount" style="font-size:0.95rem;color:var(--gray);margin-right:8px;">0 rows</div>
          <button class="close-btn" onclick="closeModal('allDataModal')">&times;</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="all-data-toolbar" style="margin-bottom:12px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
          <div style="display:flex;gap:8px;align-items:center;flex:0 0 auto;">
            <button class="btn btn-sm" onclick="refreshAllDataModal()"><i class="fas fa-sync-alt"></i> Refresh</button>
            <button class="btn btn-sm btn-secondary" onclick="exportPaymentsAndStudentsCSV()"><i class="fas fa-file-csv"></i> CSV</button>
            <button class="btn btn-sm btn-primary" onclick="exportPaymentsBySegmentExcel()"><i class="fas fa-file-excel"></i> Excel</button>
          </div>

          <div style="flex:1 1 360px;display:flex;gap:8px;margin-left:8px;align-items:center;">
            <input id="allDataSearchInput" type="text" class="form-control" placeholder="Search name / ID / email / receipt" style="width:100%; padding:8px;" />
          </div>

          <div style="display:flex;gap:8px;align-items:center;flex:0 0 auto;margin-left:auto;">
            <select id="allDataFilterLevel" class="form-control" style="padding:6px;min-width:140px;"><option value="">All Levels</option></select>
            <select id="allDataFilterDepartment" class="form-control" style="padding:6px;min-width:160px;"><option value="">All Departments</option></select>
            <select id="allDataFilterProgram" class="form-control" style="padding:6px;min-width:160px;"><option value="">All Programs</option></select>
            <label style="display:flex; align-items:center; gap:6px; color:var(--gray); font-size:0.9rem;">
              <input type="checkbox" id="allDataPaidOnly" style="transform:scale(1.1);" /> Paid only
            </label>
            <button class="btn btn-sm" onclick="applyAllDataFilter()"><i class="fas fa-search"></i></button>
            <button class="btn btn-sm btn-secondary" onclick="clearAllDataFilter()">Clear</button>
          </div>
        </div>

        <div class="table-responsive" style="--modal-header-height:120px;">
          <table class="table compact-table" id="allDataTable">
            <thead>
              <tr>
                <th style="width:48px;text-align:center;"><input type="checkbox" id="allDataSelectAll" onchange="toggleSelectAllAllData(this)" /></th>
                <th>Payment ID</th>
                <th>Student</th>
                <th>Email</th>
                <th>Fee Type</th>
                <th style="text-align:right;">Amount</th>
                <th style="width:140px;">Date</th>
                <th style="width:110px;">Status</th>
                <th style="width:90px;">Source</th>
                <th style="width:140px;text-align:center;">Actions</th>
              </tr>
            </thead>
            <tbody id="allDataTbody"></tbody>
          </table>
        </div>

        <div id="allDataPagination" style="display:flex;align-items:center;gap:8px;justify-content:flex-end;margin-top:10px;">
          <div style="font-size:0.9rem;color:var(--gray);">Rows per page:</div>
          <select id="allDataPageSize" onchange="renderAllDataPage()"><option>10</option><option selected>25</option><option>50</option><option>100</option></select>
          <button class="btn btn-sm" id="allDataPrev" onclick="changeAllDataPage(-1)">Prev</button>
          <button class="btn btn-sm" id="allDataNext" onclick="changeAllDataPage(1)">Next</button>
          <div id="allDataPageInfo" style="font-size:0.9rem;color:var(--gray);">Page 1</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('allDataModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Student Detail Modal -->
  <div id="studentDetailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Student Account Details</h2>
        <button class="close-btn" onclick="closeModal('studentDetailModal')">&times;</button>
      </div>
      <div class="modal-body">
        <div class="student-info">
          <h4>Student Information</h4>
          <div class="student-details" id="detailedStudentInfo">
            <!-- Detailed student info will be loaded here -->
          </div>
        </div>

        <div class="payment-details">
          <h4>Payment Summary</h4>
          <div class="payment-info" id="studentPaymentSummary">
            <!-- Payment summary will be loaded here -->
          </div>
        </div>

        <div class="payment-details">
          <h4>All Payments</h4>
          <div class="payment-info" id="studentPaymentsList">
            <!-- Full payment rows will be loaded here -->
          </div>
        </div>

        <!-- Registration Eligibility Status -->
        <div id="registrationEligibilityStatus" class="eligibility-status">
          <!-- Will be populated by JavaScript -->
        </div>

        <div class="form-group">
          <label class="form-label" for="registrationStatus">Registration Status</label>
          <select class="form-control form-select" id="registrationStatus">
            <option value="pending">Pending</option>
            <option value="approved">Approved</option>
            <option value="rejected">Rejected</option>
          </select>
        </div>

        <div class="form-group">
          <label class="form-label" for="adminStudentNotes">Admin Notes</label>
          <textarea class="form-control" id="adminStudentNotes" rows="3" placeholder="Add notes about this student..."></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('studentDetailModal')">Close</button>
        <!-- Approve All Eligible Payments removed from UI -->
        <button class="btn" onclick="updateStudentStatus()">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- SMS Preview Modal (replaces legacy preview modal) -->
  <div id="smsPreviewModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>SMS Preview</h2>
        <button class="close-btn" onclick="closeModal('smsPreviewModal')">&times;</button>
      </div>
      <div class="modal-body">
        <div class="payment-details">
          <h4>Message Details</h4>
          <div class="payment-info">
            <div class="payment-info-item">
              <div class="payment-info-label">Recipient</div>
              <div class="payment-info-value" id="previewRecipient">All Students</div>
            </div>
            <div class="payment-info-item">
              <div class="payment-info-label">Estimated Recipients</div>
              <div class="payment-info-value" id="previewRecipientCount">245 students</div>
            </div>
          </div>
        </div>

        <div class="sms-preview">
          <div class="sms-header">
            <i class="fas fa-comment sms-logo"></i>
            <span class="sms-sender">GH TECHNICAL UNIVERSITY</span>
            <span class="sms-time">Now</span>
          </div>
          <div class="sms-message" id="previewModalMessage">
            Your message will appear here...
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('smsPreviewModal')">Cancel</button>
        <button class="btn btn-sms" onclick="confirmSendSms()">
          <i class="fas fa-comment"></i> Send via SMS
        </button>
      </div>
    </div>
  </div>

  <!-- SMS Edit Modal -->
  <div id="smsEditModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Edit SMS</h2>
        <button class="close-btn" onclick="closeModal('smsEditModal')">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="form-label">Recipient</label>
          <input type="text" id="smsEditRecipient" class="form-control" />
        </div>
        <div class="form-group">
          <label class="form-label">Message</label>
          <textarea id="smsEditMessage" class="form-control" rows="6"></textarea>
        </div>
        <div class="form-group">
          <label class="form-label">Status</label>
          <select id="smsEditStatus" class="form-control"><option value="intent">intent</option><option value="sent">sent</option><option value="failed">failed</option></select>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('smsEditModal')">Cancel</button>
        <button class="btn btn-success" onclick="saveSmsEdit()">Save</button>
      </div>
    </div>
  </div>

  <!-- Payment approval success modal removed (approvals disabled) -->
    </div>
    </div>

    <!-- Global message modal (replaces alert()) -->
    <div id="globalMessageModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 id="globalMessageTitle">Notice</h2>
          <button class="close-btn" onclick="closeModal('globalMessageModal')">&times;</button>
        </div>
        <div class="modal-body">
          <div id="globalMessageBody" style="white-space:pre-wrap;">Message</div>
        </div>
        <div class="modal-footer">
          <button class="btn" onclick="closeModal('globalMessageModal')">OK</button>
        </div>
      </div>
    </div>

    <script>
    /* ===========================================
       Enhanced Finance Admin Dashboard JS
       With Payment Approval Workflow Integration
       =========================================== */

    /* -------------- CONFIG -------------- */
    const SUPABASE_URL = "https://fyriapqeztevzkcaaiqw.supabase.co";
    const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ5cmlhcHFlenRldnprY2FhaXF3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5OTgyNTcsImV4cCI6MjA3OTU3NDI1N30.Re3EZ2VXE6Z7qWhVlxV6yqqIWB8wj1b1wURNLZXpddY";

    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

  // ---------- ARKESEL SMS GATEWAY CONFIGURATION ----------
  // NOTE: Storing API keys in client-side code is insecure. Prefer a server-side proxy.
  const ARKESEL_API_URL = 'https://app.arkesel.com/api/sms/send'; // may need adjustment to match provider
  const ARKESEL_API_KEY = 'eRMVry$3QufP5xv';
  const ARKESEL_API_EMAIL = 'gh.mediasch@gmail.com';
  const ARKESEL_SENDER_ID = 'GH_SCHOOLS';
  // If you have a server-side proxy endpoint, set USE_PROXY=true and PROXY_ENDPOINT to the proxy URL.
  const USE_PROXY = true; // set true to use local/server proxy (recommended)
  // Default to your Supabase Function so the front-end can call it without running a local proxy.
  const PROXY_ENDPOINT = 'https://fyriapqeztevzkcaaiqw.supabase.co/functions/v1/hyper-action';

  // Fee constants to match student dashboard (production values)
  const ADMISSION_FEE = 800;
  const TUITION = 2550;
  const TUITION_80 = 2040; // 80% of tuition
  const SRC_DUES = 50;
  const DEPT_DUES = 50;
  const MED_DUES = 80;

    // Global variables
    let currentPaymentId = null;
    let currentStudentId = null;
    let currentPaymentGroup = []; // supports grouped approvals (multiple payment rows belonging to one submission)
    let paymentAnalyticsChart = null;
    let allPayments = [];
    let allStudents = [];
    let currentApprovedPayment = null;
    let selectedStudent = null;

    /* -------------- UTIL FUNCTIONS -------------- */
    function cedis(n) {
      return `GHS ${Number(n).toFixed(2)}`;
    }

    // Replace browser alert with a reusable modal
    function showModalMessage(message, title = 'Notice') {
      try {
        const titleEl = document.getElementById('globalMessageTitle');
        const bodyEl = document.getElementById('globalMessageBody');
        if (titleEl) titleEl.textContent = title;
        if (bodyEl) bodyEl.textContent = typeof message === 'string' ? message : JSON.stringify(message);
        openModal('globalMessageModal');
      } catch (e) {
        // fallback: log to console if modal cannot be shown
        try { console.warn('Modal unavailable — message:', message); } catch(_) {}
      }
    }

    // Approvals disabled helper
    function approvalsDisabled() {
      try {
        showModalMessage('Payment approval actions are disabled in this deployment.');
      } catch (e) {
        try { alert('Payment approval actions are disabled.'); } catch(_) {}
      }
    }

    // No-op overrides for approval entry points to keep callers safe
    (function(){
      const noopAsync = async function(){ approvalsDisabled(); };
      // Override common approval functions used throughout the admin UI
      try {
        window.adminApprovePayment = noopAsync;
        window.approveAllEligiblePayments = noopAsync;
        window.approveSelectedPending = noopAsync;
        window.approveAllPending = noopAsync;
        window.approvePayment = noopAsync;
        window.rejectPayment = noopAsync;
      } catch(e) {
        // if assignment fails, at least keep approvalsDisabled available
        console.warn('Could not install approval no-op overrides', e);
      }
    })();

    function formatDate(dateString) {
      if (!dateString) return 'N/A';
      const options = { year: 'numeric', month: 'short', day: 'numeric' };
      return new Date(dateString).toLocaleDateString(undefined, options);
    }

    function formatDateTime(dateString) {
      if (!dateString) return 'N/A';
      const options = { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      };
      return new Date(dateString).toLocaleDateString(undefined, options);
    }

    // Return a nicely formatted full name for a student record
    function getFullName(student) {
      if (!student) return '';
      // Prefer `full_name` or `name` field if present
      if (student.full_name && String(student.full_name).trim().length > 0) return String(student.full_name).trim();
      if (student.name && String(student.name).trim().length > 0) return String(student.name).trim();
      const first = student.firstname || student.first_name || '';
      const last = student.lastname || student.last_name || '';
      return `${first} ${last}`.trim();
    }

    /* -------------- SIDEBAR & NAVIGATION -------------- */
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      if (!sidebar) return;
      sidebar.classList.toggle('collapsed');
      const main = document.getElementById('mainContent');
      if (main) {
        if (sidebar.classList.contains('collapsed')) main.classList.add('expanded'); else main.classList.remove('expanded');
      }
    }

    // Load students from DB respecting segmentation; uses fetchStudentsBySegment helper
    async function loadStudents() {
      const studentsTable = document.getElementById('studentsTable');
      const levelFilterEl = document.getElementById('studentLevelFilter');
      const deptFilterEl = document.getElementById('studentDepartmentFilter');
      const progFilterEl = document.getElementById('studentProgramFilter');
      const selectedLevel = levelFilterEl ? (levelFilterEl.value || '').toString().trim() : '';
      const selectedDept = deptFilterEl ? (deptFilterEl.value || '').toString().trim() : '';
      const selectedProg = progFilterEl ? (progFilterEl.value || '').toString().trim() : '';

      let students = [];
      try {
        students = await fetchStudentsBySegment(selectedLevel, selectedDept, selectedProg);
        allStudents = students;
      } catch (e) {
        console.warn('Could not fetch students by segment, falling back to cache', e);
        students = allStudents || [];
      }

      if (studentsTable) {
        let html = '';
        students.forEach(student => {
          const studentId = student.student_id || student.admission_number || student.id || 'N/A';
          const studentName = getFullName(student) || 'Unknown Student';
          const eligibility = checkStudentEligibility(studentId);
          html += `
            <tr>
              <td>${escapeHtml(studentId)}</td>
              <td>${escapeHtml(studentName)}</td>
              <td>${escapeHtml(student.program || student.program_applying_for || 'Not assigned')}</td>
              <td><span class="status-badge ${eligibility.admissionPaid ? 'status-paid' : 'status-unpaid'}">${eligibility.admissionPaid ? 'Paid' : 'Unpaid'}</span></td>
              <td><span class="status-badge ${eligibility.tuitionPaid ? 'status-paid' : 'status-unpaid'}">${eligibility.tuitionPaid ? 'Paid' : 'Unpaid'}</span></td>
              <td><span class="status-badge ${eligibility.srcPaid && eligibility.deptPaid && eligibility.medPaid ? 'status-paid' : 'status-unpaid'}">${eligibility.srcPaid && eligibility.deptPaid && eligibility.medPaid ? 'Paid' : 'Unpaid'}</span></td>
              <td><span class="status-badge ${eligibility.allFeesPaid ? 'status-approved' : 'status-pending'}">${eligibility.allFeesPaid ? 'Eligible' : 'Pending'}</span></td>
              <td>
                <button class="btn btn-sm" onclick="viewStudentDetails('${escapeHtml(studentId)}')">
                  <i class="fas fa-eye"></i> View
                </button>
              </td>
            </tr>
          `;
        });
        if (!students || students.length === 0) html = `<tr><td colspan="8" style="text-align:center;padding:20px;">No students found</td></tr>`;
        studentsTable.innerHTML = html;
      }
    }

    // Switch tabs in the UI and call loader hooks when a tab opens
    function openTab(tabName) {
      try {
        // hide all tab contents
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        // deactivate nav items
        document.querySelectorAll('.nav-item[data-tab]').forEach(it => it.classList.remove('active'));

        // show requested tab content
        const tabEl = document.getElementById(`${tabName}-tab`);
        if (tabEl) tabEl.classList.add('active');

        // mark nav item active
        const nav = document.querySelector(`.nav-item[data-tab="${tabName}"]`);
        if (nav) nav.classList.add('active');

        // call any loader for this tab
        switch (tabName) {
          case 'dashboard':
            try { loadDashboardData(); } catch(e) { console.warn('loadDashboardData', e); }
            break;
          case 'manual-payments':
            try { loadManualPayments(); } catch(e) { console.warn('loadManualPayments', e); }
            break;
          case 'payment-review':
            try { loadPaymentReviewData(); } catch(e) { console.warn('loadPaymentReviewData', e); }
            break;
          case 'students':
            try { loadStudents(); } catch(e) { console.warn('loadStudents', e); }
            break;
          case 'reports':
            try { loadReports(); } catch(e) { console.warn('loadReports', e); }
            break;
          case 'sms':
            try { loadSmsData(); } catch(e) { console.warn('loadSmsData', e); }
            break;
          case 'announcements':
            try { loadAnnouncementsAdmin(); } catch(e) { console.warn('loadAnnouncementsAdmin', e); }
            break;
          default:
            break;
        }
      } catch (err) {
        console.error('openTab error', err);
      }
    }

    async function confirmLogout() {
      const ok = await showConfirm('Are you sure you want to log out?', 'Confirm Logout');
      if (!ok) return;
      window.location.href = 'admin-login.html';
    }

    /* -------------- MODAL FUNCTIONS -------------- */
    function openModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) modal.style.display = 'flex';
    }

    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) modal.style.display = 'none';
    }

    // Close modals when clicking outside
    window.addEventListener('click', (e) => {
      document.querySelectorAll('.modal').forEach(modal => {
        if (e.target === modal) modal.style.display = 'none';
      });
    });

    // Close modals with Escape key
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal').forEach(modal => {
          modal.style.display = 'none';
        });
      }
    });

    /* -------------- MODAL HELPERS & STYLES -------------- */

    // Ensure consistent modal styles (added once)
    (function ensureGlobalModalStyles(){
      if (document.getElementById('globalModalStyles')) return;
      const s = document.createElement('style');
      s.id = 'globalModalStyles';
      s.textContent = `
        .modal{position:fixed;inset:0;display:none;align-items:flex-start;justify-content:flex-start;background:rgba(0,0,0,0.45);z-index:9999}
        .modal-content{background:#fff;border-radius:0;width:100%;height:100%;box-shadow:none;overflow:hidden;display:flex;flex-direction:column}
        /* payment detail modal uses full-screen layout */
        #paymentDetailModal .modal-content{width:100%;height:100%;}
        .modal-header{padding:12px 16px;border-bottom:1px solid #eee;display:flex;align-items:center;justify-content:space-between}
        .modal-body{padding:16px;flex:1 1 auto;overflow:auto}
        .modal-footer{padding:12px 16px;border-top:1px solid #eee;text-align:right}
        .close-btn{background:transparent;border:0;font-size:20px;cursor:pointer}
        .btn{background:#0066cc;color:#fff;border:0;padding:8px 12px;border-radius:4px;cursor:pointer}
        .btn.secondary{background:#e0e0e0;color:#111}
      `;
      document.head.appendChild(s);
    })();

    // Async confirm modal that returns a boolean
    function showConfirm(message, title = 'Please confirm'){
      return new Promise((resolve)=>{
        try{
          let modal = document.getElementById('globalConfirmModal');
          if (!modal){
            const div = document.createElement('div');
            div.innerHTML = `
              <div id="globalConfirmModal" class="modal" style="display:none;">
                <div class="modal-content">
                  <div class="modal-header"><h3 id="globalConfirmTitle"></h3><button class="close-btn" id="globalConfirmClose">&times;</button></div>
                  <div class="modal-body"><div id="globalConfirmBody" style="white-space:pre-wrap;"></div></div>
                  <div class="modal-footer"><button class="btn secondary" id="globalConfirmNo">No</button> <button class="btn" id="globalConfirmYes">Yes</button></div>
                </div>
              </div>`;
            document.body.appendChild(div.firstElementChild);
            modal = document.getElementById('globalConfirmModal');
            document.getElementById('globalConfirmClose').addEventListener('click', ()=>{ modal.style.display='none'; resolve(false); });
          }
          document.getElementById('globalConfirmTitle').textContent = title;
          document.getElementById('globalConfirmBody').textContent = typeof message === 'string' ? message : JSON.stringify(message);
          modal.style.display = 'flex';

          const yesBtn = document.getElementById('globalConfirmYes');
          const noBtn = document.getElementById('globalConfirmNo');

          function cleanup(){
            modal.style.display='none';
            yesBtn.removeEventListener('click', onYes);
            noBtn.removeEventListener('click', onNo);
          }

          function onYes(){ cleanup(); resolve(true); }
          function onNo(){ cleanup(); resolve(false); }

          yesBtn.addEventListener('click', onYes);
          noBtn.addEventListener('click', onNo);
        }catch(e){ console.warn('showConfirm failed:', e); resolve(false); }
      });
    }

    /* -------------- SUPABASE DATA FETCHING -------------- */
    async function fetchAllPayments() {
      // Try fetching payments from several candidate tables and combine them.
      // Only probe the most likely payment tables to reduce 404 noise
      const candidateTables = [
        'level100payments',
        'payments'
      ];

      let combined = [];

      for (const table of candidateTables) {
        try {
          const { data, error } = await sb
            .from(table)
            .select('*')
            .order('created_at', { ascending: false });

          if (error) {
            // Table might not exist (404 schema cache). Silence those specific messages to avoid noisy logs.
            const msg = error.message || String(error);
            if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
              continue;
            }
            console.warn(`Skipping table ${table}:`, msg);
            continue;
          }

          if (Array.isArray(data) && data.length > 0) {
            const normalized = data.map((row, idx) => ({
              // preserve existing fields but ensure an `id` and a `source_table`
              ...row,
              source_table: table,
              id: row.id || row.payment_id || row.transaction_ref || `${table}_${Date.now()}_${idx}`
            }));

            combined = combined.concat(normalized);
          }
        } catch (err) {
          // suppress schema-not-found style errors
          const msg = err?.message || String(err);
          if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
            continue;
          }
          console.warn(`Error fetching from ${table}:`, err);
        }
      }

      // Sort combined results by created_at or payment_date descending
      combined.sort((a, b) => {
        const ta = new Date(a.created_at || a.payment_date || 0).getTime();
        const tb = new Date(b.created_at || b.payment_date || 0).getTime();
        return tb - ta;
      });

      return combined;
    }

    async function fetchAllStudents() {
      // Try fetching students from the primary student tables and combine them.
      // Reduced candidate list to avoid probing missing tables which cause 404/schema-cache warnings.
      const candidateTables = [
        'newstudents',
        'students'
      ];

      let combined = [];

      for (const table of candidateTables) {
        try {
          const { data, error } = await sb
            .from(table)
            .select('*')
            .order('created_at', { ascending: false });

          if (error) {
            const msg = error.message || String(error);
            if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
              continue;
            }
            console.warn(`Skipping student table ${table}:`, msg);
            continue;
          }

          if (Array.isArray(data) && data.length > 0) {
            const normalized = data.map((row, idx) => ({
              ...row,
              source_table: table,
              // prefer canonical student_id, fallback to legacy admission_number or id
              student_id: row.student_id || row.id || row.studentId,
              // normalize name / full_name so getFullName can find it
              name: row.full_name || row.name || (row.firstname || row.first_name || '') + ' ' + (row.lastname || row.last_name || ''),
              full_name: row.full_name || row.name || (row.firstname || row.first_name || '') + ' ' + (row.lastname || row.last_name || ''),
              id: row.id || row.student_id || row.admission_number || `${table}_${Date.now()}_${idx}`
            }));

            combined = combined.concat(normalized);
          }
        } catch (err) {
          const msg = err?.message || String(err);
          if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
            continue;
          }
          console.warn(`Error fetching from ${table}:`, err);
        }
      }

      // Deduplicate by canonical student_id, then email, then name
      const map = new Map();
      combined.forEach(s => {
        const key = s.student_id || s.email || `${s.firstname || ''}_${s.lastname || ''}`;
        if (!map.has(key)) map.set(key, s);
      });

      const result = Array.from(map.values());

      // Sort by created_at if present
      result.sort((a, b) => new Date(b.created_at || 0).getTime() - new Date(a.created_at || 0).getTime());

      return result;
    }

    // Fetch students from DB but apply segmentation filters (level, department, program).
    // If a filter is empty string it is ignored.
    async function fetchStudentsBySegment(level = '', department = '', program = '') {
      const candidateTables = ['students', 'newstudents'];
      let combined = [];

      for (const table of candidateTables) {
        try {
          const { data, error } = await sb.from(table).select('*').order('created_at', { ascending: false }).limit(2000);
          if (error) {
            const msg = error.message || String(error);
            if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) continue;
            console.warn(`Skipping student table ${table}:`, msg);
            continue;
          }

          if (Array.isArray(data) && data.length) {
            const normalized = data.map((row, idx) => ({
              ...row,
              source_table: table,
              student_id: row.student_id || row.id || row.studentId,
              name: row.full_name || row.name || ((row.firstname || row.first_name || '') + ' ' + (row.lastname || row.last_name || '')),
              full_name: row.full_name || row.name || ((row.firstname || row.first_name || '') + ' ' + (row.lastname || row.last_name || '')),
              id: row.id || row.student_id || row.admission_number || `${table}_${Date.now()}_${idx}`
            }));
            combined = combined.concat(normalized);
          }
        } catch (err) {
          const msg = err?.message || String(err);
          if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) continue;
          console.warn(`Error fetching from ${table}:`, err);
        }
      }

      // Dedupe by student_id / email / name
      const map = new Map();
      combined.forEach(s => {
        const key = s.student_id || s.email || `${s.firstname || ''}_${s.lastname || ''}`;
        if (!map.has(key)) map.set(key, s);
      });
      let result = Array.from(map.values());

      // Apply segmentation filters client-side (case-insensitive, partial match)
      const lv = (level || '').toString().trim().toLowerCase();
      const dp = (department || '').toString().trim().toLowerCase();
      const pg = (program || '').toString().trim().toLowerCase();

      if (lv || dp || pg) {
        result = result.filter(s => {
          try {
            const studLevel = (s.level || s.level_name || s.levelName || '').toString().toLowerCase();
            const studDept = (s.department || s.dept || s.department_name || '').toString().toLowerCase();
            const studProg = (s.program || s.program_applying_for || s.program_name || '').toString().toLowerCase();
            if (lv && !studLevel.includes(lv)) return false;
            if (dp && !studDept.includes(dp)) return false;
            if (pg && !studProg.includes(pg)) return false;
            return true;
          } catch (e) { return false; }
        });
      }

      // Sort by created_at desc
      result.sort((a, b) => new Date(b.created_at || 0).getTime() - new Date(a.created_at || 0).getTime());

      // Update the UI filter selects based on returned result
      try { allStudents = result; populateStudentFilters(); } catch (e) { /* ignore */ }

      return result;
    }

    /* -------------- ANNOUNCEMENTS (ADMIN) -------------- */
    function execAnnCmd(cmd) {
      try {
        document.execCommand(cmd, false, null);
        document.getElementById('announcementEditor').focus();
      } catch (e) { console.warn('execAnnCmd', e); }
    }

    function insertEmoji(emoji) {
      try {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0) {
          document.getElementById('announcementEditor').focus();
          document.execCommand('insertText', false, emoji);
          return;
        }
        const range = sel.getRangeAt(0);
        range.deleteContents();
        range.insertNode(document.createTextNode(emoji));
        // move caret after inserted
        range.setStartAfter(range.endContainer);
        sel.removeAllRanges();
        sel.addRange(range);
        document.getElementById('announcementEditor').focus();
      } catch (e) { console.warn('insertEmoji', e); }
    }

    document.addEventListener('click', (ev) => {
      if (ev.target && ev.target.id === 'emojiBtn') {
        const menu = document.getElementById('emojiMenu');
        if (menu) menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
      } else if (!ev.target.closest || !ev.target.closest('#emojiMenu')) {
        const menu = document.getElementById('emojiMenu'); if (menu) menu.style.display = 'none';
      }
    });

    async function sendAnnouncement(){
      // convenience wrapper to send immediately
      return saveAnnouncement('sent');
    }

    async function saveAnnouncement(status = 'sent'){
      const title = (document.getElementById('announcementTitle') || {}).value || '';
      const editor = document.getElementById('announcementEditor');
      const message = editor ? editor.innerHTML.trim() : '';
      if (!message || message.length === 0) { showModalMessage('Please type an announcement message before sending.'); return; }

      try {
        const author = (document.getElementById('adminName') || {}).textContent || 'Admin';
        const target = (document.getElementById('announcementTarget') || {}).value || 'all';
        const scheduled = (document.getElementById('announcementSchedule') || {}).value || null;
        const priority = (document.getElementById('announcementPriority') || {}).value || 'normal';
        const channels = [];
        if (document.getElementById('announcementChannelInApp') && document.getElementById('announcementChannelInApp').checked) channels.push('in_app');
        if (document.getElementById('announcementChannelSms') && document.getElementById('announcementChannelSms').checked) channels.push('sms');
        const specificList = (document.getElementById('announcementSpecificList') || {}).value || null;

        const payload = {
          title,
          message,
          author,
          target,
          priority,
          channels,
          specific_list: specificList,
          scheduled_at: scheduled || null,
          status: status,
          created_at: new Date().toISOString()
        };

        // If scheduled in future, mark scheduled and don't dispatch channels yet
        if (scheduled) {
          const when = new Date(scheduled);
          if (when.getTime() > Date.now() && status === 'sent') {
            payload.status = 'scheduled';
          }
        }

        const { data, error } = await sb.from('notifications').insert([payload]);
        if (error) { console.error('Failed to save announcement', error); showModalMessage('Failed to save announcement: ' + (error.message || error)); return; }

        // If we are saving as 'sent' (immediate) and SMS channel is requested, attempt to dispatch SMS now
        if (payload.status === 'sent' && channels.includes('sms')) {
          try {
            await dispatchAnnouncementSms(payload);
          } catch (smsErr) {
            console.warn('SMS dispatch failed (best-effort):', smsErr);
            // record intents for later processing
            try { await sb.from('sms_messages').insert([{ message: stripHtml(message), created_at: new Date().toISOString(), status: 'queued' }]); } catch(e){}
          }
        }

        showModalMessage(status === 'draft' ? 'Draft saved.' : (payload.status === 'scheduled' ? 'Announcement scheduled.' : 'Announcement sent and saved.'));

        // clear editor when sent (not when saving template)
        if (status !== 'template') {
          if (editor) editor.innerHTML = '';
          if (document.getElementById('announcementTitle')) document.getElementById('announcementTitle').value = '';
        }

        loadAnnouncementsAdmin();
        return data;
      } catch (e) { console.error(e); showModalMessage('Unexpected error saving announcement.'); }
    }

    function stripHtml(html){
      const d = document.createElement('div'); d.innerHTML = html; return d.textContent || d.innerText || '';
    }

    async function dispatchAnnouncementSms(payload){
      // Resolve recipients (best-effort using cached allStudents or DB lookups)
      const plain = stripHtml(payload.message).slice(0, 1000);
      const phones = [];

      // specific list overrides target
      if (payload.specific_list) {
        const items = payload.specific_list.split(',').map(s=>s.trim()).filter(Boolean);
        for (const idOrEmail of items) {
          // try cache
          let found = (allStudents || []).find(s => s.student_id === idOrEmail || s.email === idOrEmail || String(s.id) === idOrEmail);
          if (!found) {
            // try DB lookup by student_id or email
            try {
              const { data: sdata } = await sb.from('students').select('phone,phone_number').or(`student_id.eq.${idOrEmail},email.eq.${idOrEmail}`).limit(1).maybeSingle();
              if (sdata) found = sdata;
            } catch(e){}
          }
          const raw = found ? (found.phone || found.phone_number) : null;
          const normalized = normalizePhone(raw);
          if (normalized) phones.push(normalized);
        }
      } else if (payload.target && payload.target.startsWith('level')) {
        // broadcast to students matching level in cache
        const level = payload.target; // e.g., level100
        (allStudents || []).forEach(s => { if ((s.level || '').toString().toLowerCase() === level.toLowerCase() || (s.level || '').toString().includes(level.replace('level',''))) { const p = normalizePhone(s.phone||s.phone_number); if (p) phones.push(p); } });
      } else if (payload.target === 'all') {
        (allStudents || []).forEach(s => { const p = normalizePhone(s.phone||s.phone_number); if (p) phones.push(p); });
      }

      // dedupe phones
      const uniq = Array.from(new Set(phones));
      if (!uniq.length) throw new Error('No phone numbers resolved for SMS dispatch');

      // Call existing helper (sendViaArkesel) if available
      if (typeof sendViaArkesel === 'function') {
        await sendViaArkesel(uniq, plain, { announcement_id: (payload && payload.id) || null });
      } else {
        // fallback: record into sms_messages table as queued
        try { await sb.from('sms_messages').insert(uniq.map(p => ({ phone: p, message: plain, created_at: new Date().toISOString(), status: 'queued' }))); } catch(e){ console.warn('Could not queue sms messages', e); }
      }
    }

    async function loadAnnouncementsAdmin(){
      try {
        const { data, error } = await sb.from('notifications').select('*').order('created_at', { ascending: false }).limit(100);
        if (error) { console.warn('Could not load announcements', error); return; }
        const tbody = document.getElementById('announcementsList');
        if (!tbody) return;
        tbody.innerHTML = '';
        (data || []).forEach(row => {
          const tr = document.createElement('tr');
          const when = formatDateTime(row.created_at || row.created || null);
          const title = row.title || '';
          // show a plain-text snippet of the message
          const rawMsg = row.message ? String(row.message).replace(/<[^>]*>/g, '') : '';
          const snippet = rawMsg.length > 220 ? rawMsg.substring(0,220) + '…' : rawMsg;
          const author = row.author || '';
          const id = row.id || row.notification_id || '';
          tr.innerHTML = `<td>${when}</td><td>${escapeHtml(title)}</td><td>${escapeHtml(snippet)}</td><td>${escapeHtml(author)}</td><td><button class="btn btn-sm btn-danger" onclick="deleteAnnouncement('${escapeHtml(id)}')"><i class='fas fa-trash'></i> Delete</button></td>`;
          tbody.appendChild(tr);
        });
      } catch (e) { console.warn('loadAnnouncementsAdmin', e); }
    }

    function previewAnnouncement(){
      const title = (document.getElementById('announcementTitle') || {}).value || '';
      const editor = document.getElementById('announcementEditor');
      const htmlMsg = editor ? editor.innerHTML.trim() : '';
      const plain = stripHtml(htmlMsg);
      const modalTitle = title || 'Announcement Preview';
      const scheduled = (document.getElementById('announcementSchedule') || {}).value || '';
      const priority = (document.getElementById('announcementPriority') || {}).value || 'normal';
      const channels = [];
      if (document.getElementById('announcementChannelInApp') && document.getElementById('announcementChannelInApp').checked) channels.push('In-app');
      if (document.getElementById('announcementChannelSms') && document.getElementById('announcementChannelSms').checked) channels.push('SMS');

      const html = `
        <div><strong>${escapeHtml(modalTitle)}</strong></div>
        <div style="margin-top:8px;">${htmlMsg}</div>
        <div style="margin-top:12px;color:var(--gray);font-size:0.95rem;">
          <div><strong>Priority:</strong> ${escapeHtml(priority)}</div>
          <div><strong>Channels:</strong> ${escapeHtml(channels.join(', ') || 'In-app')}</div>
          <div><strong>Scheduled:</strong> ${escapeHtml(scheduled || 'Now')}</div>
          <div style="margin-top:8px;"><strong>SMS Preview (plain text):</strong><div style="background:#f7f7f7;padding:8px;border-radius:6px;margin-top:6px;white-space:pre-wrap;">${escapeHtml(plain)}</div></div>
        </div>
      `;
      const gm = document.getElementById('globalMessageBody');
      const gt = document.getElementById('globalMessageTitle');
      if (gt) gt.textContent = 'Preview Announcement';
      if (gm) { gm.innerHTML = html; }
      openModal('globalMessageModal');
    }

    function escapeHtml(str){ if(!str) return ''; return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    function setupAnnouncementEditor(){
      const editor = document.getElementById('announcementEditor');
      if (!editor) return;
      // Show/hide specific audience input
      const target = document.getElementById('announcementTarget');
      const specificRow = document.getElementById('specificAudienceRow');
      function updateTargetUI(){ if (!target) return; if (target.value === 'specific') specificRow.style.display = 'block'; else specificRow.style.display = 'none'; }
      if (target) target.addEventListener('change', updateTargetUI);
      updateTargetUI();

      // Draft / template buttons
      const draftBtn = document.getElementById('saveDraftBtn');
      if (draftBtn) draftBtn.addEventListener('click', async ()=>{ await saveAnnouncement('draft'); });
      const tplBtn = document.getElementById('saveTemplateBtn');
      if (tplBtn) tplBtn.addEventListener('click', async ()=>{ await saveAnnouncement('template'); showModalMessage('Template saved (as template).'); });

      editor.addEventListener('input', ()=>{ /* placeholder for char/count */ });
    }

    // Initialize announcement editor on load
    document.addEventListener('DOMContentLoaded', ()=>{ setupAnnouncementEditor(); loadAnnouncementsAdmin(); });

    async function deleteAnnouncement(id){
      if (!id) return showModalMessage('Announcement id missing');
      try {
        const ok = await showConfirm('Delete this announcement? This cannot be undone.', 'Confirm Delete');
        if (!ok) return;
        const { data, error } = await sb.from('notifications').delete().eq('id', id).select();
        if (error) {
          console.error('Failed to delete announcement', error);
          showModalMessage('Could not delete announcement: ' + (error.message || error));
          return;
        }
        showModalMessage('Announcement deleted');
        loadAnnouncementsAdmin();
      } catch (e) {
        console.error('deleteAnnouncement error', e);
        showModalMessage('Unexpected error deleting announcement. See console.');
      }
    }

    async function updatePaymentStatus(paymentId, status, adminNotes = '') {
      try {
        const { data, error } = await sb
          .from('level100payments')
          .update({ 
            status: status,
            admin_notes: adminNotes,
            reviewed_at: new Date().toISOString(),
            reviewed_by: 'Finance Admin'
          })
          .eq('id', paymentId)
          .select();

        if (error) {
          console.error('Error updating payment status:', error);
          return false;
        }

        return true;
      } catch (error) {
        console.error('Error updating payment status:', error);
        return false;
      }
    }

    async function recordManualPayment(paymentData) {
      try {
        const payload = {
          ...paymentData,
          status: 'pending',
          payment_method: 'manual',
          created_at: new Date().toISOString()
        };

        const { data, error } = await sb
          .from('level100payments')
          .insert([payload])
          .select();

        if (error) {
          console.error('Error recording manual payment:', error);
          return null;
        }

        // Return the inserted row (first element) for further processing (receipt generation, upserts)
        return Array.isArray(data) && data.length ? data[0] : null;
      } catch (error) {
        console.error('Error recording manual payment:', error);
        return null;
      }
    }

    /* -------------- PAYMENT ELIGIBILITY CHECK -------------- */
    function checkStudentEligibility(studentId) {
      // Normalize comparison value
      const key = String(studentId || '').trim();

      // Get all approved payments that match any likely student identifier field
      const studentPayments = allPayments.filter(p => {
        if (!p || p.status !== 'approved') return false;
        const candidates = [p.student_id, p.admission_number, p.studentId, p.admissionNumber, p.id, p.email, p.customer_email];
        return candidates.some(c => String(c || '') === key);
      });

      const feeType = (t) => (t || '').toLowerCase();

      // Check admission fee
      const admissionPaid = studentPayments.some(p => 
        feeType(p.fee_type).includes('admission') && (Number(p.amount_paid || p.amount || 0) >= ADMISSION_FEE - 0.005)
      );

      // Check tuition (80%)
      const tuitionPaid = studentPayments
        .filter(p => feeType(p.fee_type).includes('tuition'))
        .reduce((sum, p) => sum + Number(p.amount_paid || p.amount || 0), 0) >= TUITION_80 - 0.005;

      // Check other fees
      const srcPaid = studentPayments.some(p => 
        feeType(p.fee_type).includes('src') && Number(p.amount_paid || p.amount || 0) >= SRC_DUES - 0.005
      );

      const deptPaid = studentPayments.some(p => 
        feeType(p.fee_type).includes('department') && Number(p.amount_paid || p.amount || 0) >= DEPT_DUES - 0.005
      );

      const medPaid = studentPayments.some(p => 
        feeType(p.fee_type).includes('medical') && Number(p.amount_paid || p.amount || 0) >= MED_DUES - 0.005
      );

      const allFeesPaid = admissionPaid && tuitionPaid && srcPaid && deptPaid && medPaid;

      return {
        admissionPaid,
        tuitionPaid,
        srcPaid,
        deptPaid,
        medPaid,
        allFeesPaid,
        studentPayments
      };
    }

    function updateEligibilityDisplay(studentId, containerId) {
      const eligibility = checkStudentEligibility(studentId);
      const container = document.getElementById(containerId);
      
      if (!container) return;

      if (eligibility.allFeesPaid) {
        container.innerHTML = `
          <div class="eligibility-status eligibility-approved">
            <i class="fas fa-check-circle"></i> 
            STUDENT ELIGIBLE FOR COURSE REGISTRATION - All required fees have been approved
          </div>
        `;
      } else {
        let missingFees = [];
        if (!eligibility.admissionPaid) missingFees.push('Admission Fee');
        if (!eligibility.tuitionPaid) missingFees.push('Tuition (80%)');
        if (!eligibility.srcPaid) missingFees.push('SRC Dues');
        if (!eligibility.deptPaid) missingFees.push('Departmental Dues');
        if (!eligibility.medPaid) missingFees.push('Medical Dues');

        container.innerHTML = `
          <div class="eligibility-status eligibility-pending">
            <i class="fas fa-clock"></i> 
            STUDENT NOT ELIGIBLE FOR REGISTRATION - Missing: ${missingFees.join(', ')}
          </div>
        `;
      }
      
      container.style.display = 'block';
    }

    /* -------------- DASHBOARD DATA -------------- */
    async function loadDashboardData() {
      try {
        // Fetch all data
        allPayments = await fetchAllPayments();
        allStudents = await fetchAllStudents();

        // Update dashboard stats
        const totalRevenue = allPayments
          .filter(p => p.status === 'approved')
          .reduce((sum, payment) => sum + (payment.amount_paid || 0), 0);
        
        const approvedCount = allPayments.filter(p => p.status === 'approved').length;
        const pendingCount = allPayments.filter(p => p.status === 'pending').length;
        const rejectedCount = allPayments.filter(p => p.status === 'rejected').length;

        document.getElementById('totalRevenue').textContent = cedis(totalRevenue);
        document.getElementById('approvedPayments').textContent = approvedCount;
        document.getElementById('pendingReview').textContent = pendingCount;
        document.getElementById('overduePayments').textContent = rejectedCount;

        // Update recent payments table
        const recentPaymentsTable = document.getElementById('recentPaymentsTable');
        if (recentPaymentsTable) {
          let html = '';
          const recentPayments = allPayments.slice(0, 5); // Show last 5 payments
          
          recentPayments.forEach(payment => {
            const statusClass = payment.status === 'approved' ? 'status-approved' : 
                               payment.status === 'rejected' ? 'status-rejected' : 'status-pending';
            
            const statusText = payment.status === 'approved' ? 'Approved' : 
                              payment.status === 'rejected' ? 'Rejected' : 'Pending Review';

            html += `
              <tr>
                <td>${payment.student_name || 'Unknown Student'} (${payment.student_id || 'N/A'})</td>
                <td>${payment.fee_type || 'Unknown Fee'}</td>
                <td>${cedis(payment.amount_paid || 0)}</td>
                <td>${formatDate(payment.created_at)}</td>
                <td><span class="status-badge ${statusClass}">${statusText}</span></td>
              </tr>
            `;
          });

          if (recentPayments.length === 0) {
            html = `<tr><td colspan="5" style="text-align: center; padding: 20px;">No payments found</td></tr>`;
          }

          recentPaymentsTable.innerHTML = html;
        }

        // Update pending approvals list
        const pendingApprovalsList = document.getElementById('pendingApprovalsList');
        if (pendingApprovalsList) {
          let html = '';
          const pendingPayments = allPayments.filter(p => p.status === 'pending').slice(0, 3);
          
          pendingPayments.forEach(payment => {
            html += `
              <div style="padding: 12px; border-bottom: 1px solid var(--gray-light);">
                <div style="font-weight: 500;">${payment.student_name || 'Unknown Student'} - ${payment.fee_type || 'Unknown Fee'}</div>
                <div style="font-size: 0.85rem; color: var(--gray); margin-bottom: 8px;">
                  ${cedis(payment.amount_paid || 0)} • ${formatDate(payment.created_at)}
                </div>
                <button class="btn btn-sm" onclick="viewPaymentForApproval('${payment.id}')">
                  <i class="fas fa-eye"></i> Review
                </button>
              </div>
            `;
          });

          if (pendingPayments.length === 0) {
            html = `<div style="padding: 20px; text-align: center; color: var(--gray);">No pending approvals</div>`;
          }

          pendingApprovalsList.innerHTML = html;
        }

        // Initialize charts with real data
        initCharts();
      } catch (error) {
        console.error('Error loading dashboard data:', error);
      }
    }

    function initCharts() {
      // Payment Analytics Chart
      const paymentAnalyticsCtx = document.getElementById('paymentAnalyticsChart').getContext('2d');
      if (paymentAnalyticsChart) {
        paymentAnalyticsChart.destroy();
      }

      // Calculate payment distribution by fee type
      const feeTypes = {};
      allPayments
        .filter(p => p.status === 'approved')
        .forEach(payment => {
          const feeType = payment.fee_type || 'Other';
          feeTypes[feeType] = (feeTypes[feeType] || 0) + (payment.amount_paid || 0);
        });

      const labels = Object.keys(feeTypes);
      const data = Object.values(feeTypes);

      paymentAnalyticsChart = new Chart(paymentAnalyticsCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Amount Collected (GHS)',
            data: data,
            backgroundColor: [
              'rgba(30, 58, 138, 0.7)',
              'rgba(59, 130, 246, 0.7)',
              'rgba(16, 185, 129, 0.7)',
              'rgba(245, 158, 11, 0.7)',
              'rgba(239, 68, 68, 0.7)'
            ],
            borderColor: [
              'rgb(30, 58, 138)',
              'rgb(59, 130, 246)',
              'rgb(16, 185, 129)',
              'rgb(245, 158, 11)',
              'rgb(239, 68, 68)'
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function updateAnalytics() {
      // In a real implementation, we would update the chart based on the selected period
      showModalMessage('Analytics updated for the selected period');
    }

    /* -------------- MANUAL PAYMENT COLLECTION -------------- */
    function resetManualPaymentForm() {
      document.getElementById('manualPaymentForm').reset();
      document.getElementById('studentSearchResults').style.display = 'none';
    }

    // Real student search using Supabase (search both newstudents and students tables)
    document.getElementById('studentSearch').addEventListener('input', debounce(async function() {
      const term = this.value.trim();
      const resultsContainer = document.getElementById('studentSearchResults');

      if (!term || term.length < 1) {
        resultsContainer.style.display = 'none';
        return;
      }

      const candidateTables = ['newstudents', 'students'];
      let combined = [];

      try {
        // If term looks like an exact id (no spaces), try exact matches across both tables
        const orClause = `student_id.eq.${term},email.eq.${term}`;

        await Promise.all(candidateTables.map(async (table) => {
          try {
            // exact matches first
            const { data: exact, error: exactErr } = await sb.from(table).select('*').or(orClause).limit(10);
            if (!exactErr && exact && exact.length) {
              combined = combined.concat(exact.map(r => ({...r, source_table: table})));
              return;
            }

            // fallback to ilike on name or full_name for longer terms
            if (term.length > 2) {
              // Some tables may not have `full_name`. Search across `name`, `first_name` and `last_name` fields instead.
              const nameOr = `name.ilike.%${term}%,first_name.ilike.%${term}%,last_name.ilike.%${term}%`;
              const { data: likeData, error: likeErr } = await sb.from(table).select('*').or(nameOr).limit(10);
              if (!likeErr && likeData && likeData.length) combined = combined.concat(likeData.map(r => ({...r, source_table: table})));
            }
          } catch (err) {
            console.warn(`Search error on ${table}:`, err);
          }
        }));
      } catch (err) {
        console.warn('Error searching students across tables:', err);
      }

      // Deduplicate results preferring canonical student_id, then email, then name
      const map = new Map();
      combined.forEach(r => {
        const key = (r.student_id || r.email || (r.full_name || r.name || ((r.first_name||r.firstname||'') + ' ' + (r.last_name||r.lastname||''))) || JSON.stringify(r)).toString();
        if (!map.has(key)) map.set(key, r);
      });

      const students = Array.from(map.values()).slice(0, 20);

      if (!students || students.length === 0) {
        resultsContainer.innerHTML = `<div style="padding: 12px; text-align: center; color: var(--gray);">No students found</div>`;
        resultsContainer.style.display = 'block';
        return;
      }

      // Render results
      let html = '';
      students.forEach(s => {
        const studentName = getFullName(s) || `${s.firstname || ''} ${s.lastname || ''}`.trim() || 'Unknown Student';
        // Prefer the canonical `student_id`, fall back to legacy `admission_number` then `id`
        const studentId = s.student_id || s.id || 'N/A';
        html += `
          <div style="background: var(--white); border: 1px solid var(--gray-light); border-radius: var(--radius); padding: 12px; cursor: pointer; margin-bottom: 8px;" 
               onclick="selectStudent('${escapeHtml(studentId).replace(/'/g, "\\'" )}')">
            <div style="font-weight: 500;">${escapeHtml(studentName)}</div>
            <div style="font-size: 0.85rem; color: var(--gray);">${escapeHtml(studentId)} - ${escapeHtml(s.program || s.program_applying_for || 'Not assigned')}</div>
          </div>
        `;
      });

      resultsContainer.innerHTML = html;
      resultsContainer.style.display = 'block';
    }, 350));

    // Select a student from search results (use combined cache first, fallback to querying tables)
    async function selectStudent(studentId) {
      document.getElementById('studentSearchResults').style.display = 'none';
      document.getElementById('studentSearch').value = studentId;

      // Try to find in cached allStudents first (prefer student_id)
      let student = allStudents.find(s => (s.student_id && s.student_id === studentId));

      if (!student) {
        // Candidate tables to query if not in cache. Keep this list small to avoid 404s.
        const candidateTables = ['newstudents', 'students'];
        for (const table of candidateTables) {
          try {
            const { data, error } = await sb
              .from(table)
              .select('*')
              .or(`student_id.eq.${studentId},admission_number.eq.${studentId},email.eq.${studentId}`)
              .limit(1);

            if (error) {
              const msg = error.message || String(error);
              if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
                continue;
              }
              console.warn(`Skipping table ${table} when searching for ${studentId}:`, msg);
              continue;
            }

            if (data && data.length) {
              student = data[0];
              student.source_table = table;
              break;
            }
          } catch (err) {
            const msg = err?.message || String(err);
            if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
              continue;
            }
            console.warn(`Error querying ${table} for ${studentId}:`, err);
          }
        }
      }

      if (!student) {
        showModalMessage('Student not found');
        return;
      }

      selectedStudent = student;
      renderStudentInfo(selectedStudent);
      document.getElementById('studentInfoPanel').style.display = 'block';
      // Ensure latest payments are loaded then show payment summary
      allPayments = await fetchAllPayments();
      renderStudentPaymentsSummary(selectedStudent);
    }

    function clearSelectedStudent() {
      selectedStudent = null;
      document.getElementById('studentInfoPanel').style.display = 'none';
      document.getElementById('studentInfoContent').innerHTML = '';
      document.getElementById('studentSearch').value = '';
    }

    function renderStudentInfo(student) {
      const studentName = getFullName(student) || 'Unknown Student';
      const studentId = student.student_id || 'N/A';
      const program = student.program || student.program_applying_for || 'Not assigned';
      const department = student.department || 'Not assigned';
      const email = student.email || 'N/A';
      const phone = student.phone || student.phone_number || 'N/A';

      document.getElementById('studentInfoContent').innerHTML = `
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
          <div><strong>Name:</strong> ${escapeHtml(studentName)}</div>
          <div><strong>Student ID:</strong> ${escapeHtml(studentId)}</div>
          <div><strong>Program:</strong> ${escapeHtml(program)}</div>
          <div><strong>Department:</strong> ${escapeHtml(department)}</div>
          <div><strong>Email:</strong> ${escapeHtml(email)}</div>
          <div><strong>Phone:</strong> ${escapeHtml(phone)}</div>
        </div>
        <hr style="margin:8px 0;">
        <div id="studentPaymentsPanel">Loading payment summary...</div>
      `;
    }

    function renderStudentPaymentsSummary(student) {
      const studentId = student.student_id;
      const payments = allPayments.filter(p => p.student_id === studentId || p.student_id === String(studentId));

      const totalPaid = payments.filter(p => p.status === 'approved').reduce((s, p) => s + (p.amount_paid || 0), 0);
      const lastPayment = payments.sort((a,b)=> new Date(b.created_at||b.payment_date||0)-new Date(a.created_at||a.payment_date||0))[0];

      let html = `
        <div><strong>Total Approved Paid:</strong> ${cedis(totalPaid)}</div>
        <div><strong>Number of Payments:</strong> ${payments.length}</div>
        <div><strong>Last Payment:</strong> ${lastPayment ? `${cedis(lastPayment.amount_paid || 0)} • ${formatDate(lastPayment.created_at || lastPayment.payment_date)}` : 'N/A'}</div>
        <div style="margin-top:8px;">Recent payments:</div>
      `;

      if (payments.length === 0) {
        html += `<div style="color:var(--gray); margin-top:8px;">No payments found for this student.</div>`;
      } else {
        html += `<div style="max-height:240px; overflow:auto; margin-top:8px;"><table class=\"table\" style=\"font-size:0.9rem;\"><thead><tr><th>Date</th><th>Type</th><th>Amount</th><th>Status</th><th>Actions</th></tr></thead><tbody>`;
        payments.slice(0,10).forEach(p => {
          const statusClass = p.status === 'approved' ? 'status-approved' : p.status === 'rejected' ? 'status-rejected' : 'status-pending';
          // action buttons: (Approve button removed visually)
          const approveBtn = '';
          const messageBtn = `<button class=\"btn btn-sm btn-warning\" onclick=\"sendOutstandingMessage('${escapeHtml(p.id || p.payment_id || p.transaction_ref || '')}')\">Message Balance</button>`;

          html += `<tr>
            <td>${formatDate(p.created_at || p.payment_date)}</td>
            <td>${escapeHtml(p.fee_type || 'Unknown')}</td>
            <td>${cedis(p.amount_paid || 0)}</td>
            <td><span class=\"status-badge ${statusClass}\">${p.status || 'N/A'}</span></td>
            <td style=\"min-width:160px;display:flex;gap:8px;\">${approveBtn}${messageBtn}</td>
          </tr>`;
        });
        html += `</tbody></table></div>`;
      }

      document.getElementById('studentPaymentsPanel').innerHTML = html;
    }

    // Return whether a payment meets minimum expected amounts for automatic approval
    function canApprovePayment(payment) {
      if (!payment) return { ok: false, reason: 'No payment provided' };
      const amt = Number(payment.amount_paid || payment.amount || 0);
      const fee = (payment.fee_type || '').toLowerCase();

      if (fee.includes('admission')) {
        if (amt + 0.005 >= ADMISSION_FEE) return { ok: true };
        return { ok: false, reason: `Admission fee requires GHS ${ADMISSION_FEE.toFixed(2)}` };
      }

      if (fee.includes('tuition')) {
        if (amt + 0.005 >= TUITION_80) return { ok: true };
        return { ok: false, reason: `Tuition (80%) requires GHS ${TUITION_80.toFixed(2)}` };
      }

      if (fee.includes('src') || fee.includes('department') || fee.includes('medical')) {
        // small fees - assume positive payment is acceptable
        if (amt > 0) return { ok: true };
        return { ok: false, reason: 'Payment amount is zero' };
      }

      // Default: accept if some money was paid
      if (amt > 0) return { ok: true };
      return { ok: false, reason: 'Payment amount is zero' };
    }

    // Admin: approve an individual payment by id (attempts to update source table or upsert canonical)
    async function adminApprovePayment(paymentId) {
      try {
        if (!paymentId) { showModalMessage('Payment id missing'); return; }
        // Find payment in cache
        let p = allPayments.find(p => (p.id && String(p.id) === paymentId) || (p.payment_id && String(p.payment_id) === paymentId) || (p.transaction_ref && String(p.transaction_ref) === paymentId));
        if (!p) {
          showModalMessage('Payment not found in current cache. Refreshing and retrying...');
          allPayments = await fetchAllPayments();
        }

        p = allPayments.find(p => (p.id && String(p.id) === paymentId) || (p.payment_id && String(p.payment_id) === paymentId) || (p.transaction_ref && String(p.transaction_ref) === paymentId));
        if (!p) { showModalMessage('Payment not found'); return; }

        // Helper: derive transaction/receipt base by removing final -SEGMENT
        function txBaseFrom(ref){ if(!ref) return null; const parts = String(ref).split('-'); if(parts.length<=1) return ref; parts.pop(); return parts.join('-'); }

        // Determine group of related payments by transaction_ref/receipt_number base
        const tr = p.transaction_ref || p.receipt_number || '';
        const base = txBaseFrom(tr) || null;
        let group = [];
        if (base) {
          group = allPayments.filter(q => {
            const qtr = (q.transaction_ref || q.receipt_number || '') + '';
            if (!qtr) return false;
            // exact match or starts with base- (covers MANUAL-12345-ADMISSION etc.)
            return qtr === base || qtr.startsWith(base + '-') || qtr.startsWith(base + '_');
          });
        }

        // Always include the single payment if grouping failed to find others
        if (!group || group.length === 0) group = [p];

        // If grouping found more than one row, treat this as a grouped approval
        if (group.length > 1) {
          // Confirm with admin
          const total = group.reduce((s,row)=> s + Number(row.amount_paid || row.amount || 0), 0);
          if (!(await showConfirm(`Approve ${group.length} payments totalling ${cedis(total)} for ${getFullName(group[0]) || group[0].student_id || 'Student'}?`, 'Approve Grouped Payments'))) return;

          for (const row of group) {
            try {
              if (row.source_table === 'level100payments') {
                await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', row.id);
              } else if (row.source_table === 'payments') {
                await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', row.id);
              }
            } catch (e) {
              const msg = e?.message || String(e);
              if (!(msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404'))) console.warn('Error updating source table for grouped approve:', e);
            }

            try { await upsertCanonicalPayment(row, 'approved'); } catch (e) { console.warn('Could not upsert canonical payment in grouped approve:', e?.message || e); }
          }

          // Build single summary notification for student
          try {
            const studentKey = group[0].student_id || group[0].admission_number || group[0].studentId || '';
            const studentName = group[0].student_name || getFullName(group[0]) || 'Student';
            const total = group.reduce((s,row)=> s + Number(row.amount_paid || row.amount || 0), 0);
            // breakdown by fee_type
            const breakdown = group.map(r => `${r.fee_type || r.fee || 'Fee'}: ${cedis(r.amount_paid || r.amount || 0)}`).join('; ');

            // compute outstanding via existing helper (best-effort)
            const elig = checkStudentEligibility(studentKey);
            let outstandingMsg = '';
            if (elig) {
              const missing = [];
              if (!elig.admissionPaid) missing.push(`Admission: ${cedis(ADMISSION_FEE)}`);
              if (!elig.tuitionPaid) missing.push(`Tuition (80%): ${cedis(TUITION_80)}`);
              if (!elig.srcPaid) missing.push(`SRC: ${cedis(SRC_DUES)}`);
              if (!elig.deptPaid) missing.push(`Department: ${cedis(DEPT_DUES)}`);
              if (!elig.medPaid) missing.push(`Medical: ${cedis(MED_DUES)}`);
              outstandingMsg = missing.length ? ` Outstanding: ${missing.join('; ')}` : ' No outstanding fees detected.';
            }

            const message = `GH TECHNICAL — Hi ${studentName}, ${group.length} payment(s) totalling ${cedis(total)} have been approved. ${breakdown}.${outstandingMsg}`;
            await setStudentNotification(studentKey, message, { meta: { event: 'payment_approved', grouped: true, count: group.length, total } });
            // Attempt to send SMS summary to the student (best-effort)
            try {
              // Resolve phone from cache or DB
              let studentRecord = allStudents.find(s => (s.student_id || s.admission_number || '').toString() === (studentKey || '').toString());
              if (!studentRecord) { allStudents = await fetchAllStudents(); studentRecord = allStudents.find(s => (s.student_id || s.admission_number || '').toString() === (studentKey || '').toString()); }
              let rawPhone = studentRecord?.phone || studentRecord?.phone_number || group[0].student_phone || group[0].phone;
              if (!rawPhone) {
                try {
                  const { data: sdata, error: serr } = await sb.from('students').select('phone,phone_number').or(`student_id.eq.${studentKey},admission_number.eq.${studentKey}`).limit(1).maybeSingle();
                  if (!serr && sdata) rawPhone = sdata.phone || sdata.phone_number;
                } catch (e) { /* ignore */ }
              }
              function normalizePhoneLocal(phone){ if(!phone) return null; let d=String(phone).replace(/\D/g,''); if(d.charAt(0)==='0') d='233'+d.slice(1); return d.length<9?null:d; }
              const formatted = normalizePhoneLocal(rawPhone);
              if (formatted) {
                await sendViaArkesel([formatted], message, { student_id: studentKey, grouped: true });
              }
            } catch (smsErr) { console.warn('Could not send grouped approval SMS:', smsErr); }
          } catch (e) { console.warn('Could not set student notification for grouped approve:', e?.message || e); }

          // Refresh caches and UI
          allPayments = await fetchAllPayments();
          allStudents = await fetchAllStudents();

          const sid = group[0].student_id || group[0].admission_number || group[0].studentId;
          const student = allStudents.find(s => (String(s.student_id || s.admission_number || s.id) === String(sid)));
          if (student) renderStudentPaymentsSummary(student);

          showModalMessage(`Approved ${group.length} payment(s) and notified the student.`);
          return;
        }

        // Single-row fallback behavior (preserve original single-approve flows)
        const can = canApprovePayment(p);
        if (!can.ok) {
          if (!(await showConfirm(`This payment may not meet expected amount: ${can.reason}. Approve anyway?`, 'Approve Payment'))) return;
        }

        // Try updating the source table first if we know it
        try {
          if (p.source_table === 'level100payments') {
            const { data, error } = await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id).select();
          } else if (p.source_table === 'payments') {
            const { data, error } = await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id).select();
          }
        } catch (e) {
          const msg = e?.message || String(e);
          if (!(msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404'))) console.warn('Error updating source table:', e);
        }

        try { await upsertCanonicalPayment(p, 'approved'); } catch (err) { console.warn('Could not upsert canonical payment:', err?.message || err); }

        // Notify student (record in notifications history)
        try {
          const studentId = p.student_id || p.admission_number || p.studentId;
          const message = `GH TECHNICAL — Hi ${p.student_name || 'Student'}, your payment of ${cedis(p.amount_paid||p.amount||0)} for ${p.fee_type || 'fees'} (Ref: ${p.transaction_ref || p.receipt_number || 'N/A'}) has been approved. Thank you.`;
          await setStudentNotification(studentId, message, { meta: { event: 'payment_approved' } });

          // Also attempt to send an SMS confirmation to the student (best-effort)
          try {
            // Resolve student and phone
            let student = allStudents.find(s => s.student_id === studentId || s.admission_number === studentId);
            if (!student) {
              allStudents = await fetchAllStudents();
              student = allStudents.find(s => s.student_id === studentId || s.admission_number === studentId);
            }
            let rawPhone = student?.phone || student?.phone_number || p?.student_phone || p?.phone;
            if (!rawPhone) {
              try {
                const { data: sdata, error: serr } = await sb.from('students').select('phone,phone_number').or(`student_id.eq.${studentId},admission_number.eq.${studentId}`).limit(1).maybeSingle();
                if (!serr && sdata) rawPhone = sdata.phone || sdata.phone_number;
              } catch (e) { /* ignore */ }
            }

            function normalizePhone(phone){ if(!phone) return null; let d=String(phone).replace(/\D/g,''); if(d.charAt(0)==='0') d='233'+d.slice(1); return d.length<9?null:d; }
            const formatted = normalizePhone(rawPhone);
            if (formatted) {
              await sendViaArkesel([formatted], message, { student_id: studentId });
            }
          } catch (smsErr) { console.warn('Could not send SMS confirmation after approval:', smsErr); }
        } catch (err) { console.warn('Could not set student notification:', err?.message || err); }

        // Refresh caches and UI
        allPayments = await fetchAllPayments();
        allStudents = await fetchAllStudents();

        // If student detail modal is open for this student, re-render
        const sid = p.student_id || p.admission_number || p.studentId;
        const student = allStudents.find(s => (s.student_id === sid || s.admission_number === sid));
        if (student) renderStudentPaymentsSummary(student);

        showModalMessage('Payment approved and student notified.');
      } catch (err) {
        console.error('Error approving payment:', err);
        showModalMessage('Could not approve payment. See console for details.');
      }
    }

    // Admin: send outstanding balance message for a payment's student (opens SMS composer and records intent)
    async function sendOutstandingMessage(paymentId) {
      try {
        if (!paymentId) { showModalMessage('Payment id missing'); return; }
        const p = allPayments.find(p => (p.id && String(p.id) === paymentId) || (p.payment_id && String(p.payment_id) === paymentId) || (p.transaction_ref && String(p.transaction_ref) === paymentId));
        if (!p) {
          showModalMessage('Payment not found in cache. Refreshing and retrying...');
          allPayments = await fetchAllPayments();
        }

        const payment = allPayments.find(p => (p.id && String(p.id) === paymentId) || (p.payment_id && String(p.payment_id) === paymentId) || (p.transaction_ref && String(p.transaction_ref) === paymentId));
        if (!payment) { showModalMessage('Payment not found'); return; }

        const studentId = payment.student_id || payment.admission_number || payment.studentId;
        // Ensure student record
        let student = allStudents.find(s => s.student_id === studentId || s.admission_number === studentId);
        if (!student) {
          allStudents = await fetchAllStudents();
          student = allStudents.find(s => s.student_id === studentId || s.admission_number === studentId);
        }

        // Compute outstanding via eligibility helper
        const elig = checkStudentEligibility(studentId);
        // Determine missing fees and approximate amount
        let missing = [];
        if (!elig.admissionPaid) missing.push(`Admission: GHS ${ADMISSION_FEE.toFixed(2)}`);
        if (!elig.tuitionPaid) missing.push(`Tuition (80%): GHS ${TUITION_80.toFixed(2)}`);
        if (!elig.srcPaid) missing.push(`SRC: GHS ${SRC_DUES.toFixed(2)}`);
        if (!elig.deptPaid) missing.push(`Department: GHS ${DEPT_DUES.toFixed(2)}`);
        if (!elig.medPaid) missing.push(`Medical: GHS ${MED_DUES.toFixed(2)}`);

        const summary = missing.length ? missing.join('; ') : 'No outstanding fees detected.';

        const message = `Dear ${getFullName(student) || 'Student'}, our records show outstanding fees: ${summary}. Please settle the balance to complete registration.`;

        // Try to find/format phone
        let rawPhone = student?.phone || student?.phone_number || payment?.student_phone || payment?.phone;
        if (!rawPhone) {
          // Try read from DB directly
          try {
            const { data, error } = await sb.from('students').select('phone,phone_number').or(`student_id.eq.${studentId},admission_number.eq.${studentId}`).limit(1).maybeSingle();
            if (!error && data) rawPhone = data.phone || data.phone_number;
          } catch (e) { /* ignore */ }
        }

        function normalize(phone) {
          if (!phone) return null;
          let digits = String(phone).replace(/\D/g,'');
          if (digits.charAt(0) === '0') digits = '233' + digits.slice(1);
          if (digits.length < 9) return null;
          return digits;
        }

        const formattedPhone = normalize(rawPhone);
        if (!formattedPhone) { showModalMessage('Student phone number not found or invalid.'); return; }

        const encoded = encodeURIComponent(message);
        const smsUrl = `sms:${formattedPhone}?body=${encoded}`;

        // record intent (non-blocking) into sms_messages
        (async function record(){
          try {
            await sb.from('sms_messages').insert([{ student_id: studentId, phone: formattedPhone, message: message, created_at: new Date().toISOString(), status: 'intent_opened' }]);
          } catch(e){ /* ignore */ }
        })();

        // Try to open the user's SMS app (mobile browsers will handle this). On desktop this may be a no-op.
        window.open(smsUrl, '_blank');
        showModalMessage('SMS composer opened (or intent recorded) with the outstanding balance message.');
      } catch (err) {
        console.error('Error sending outstanding message:', err);
        showModalMessage('Could not send message. See console for details.');
      }
    }

    // Admin: approve all eligible payments for a student
    async function approveAllEligiblePayments(studentId) {
      try {
        if (!studentId) { showModalMessage('No student selected'); return; }

        // Load freshest caches
        allStudents = await fetchAllStudents();
        allPayments = await fetchAllPayments();

        const sid = String(studentId);
        const student = allStudents.find(s => String(s.student_id || s.admission_number || s.id) === sid);

        // find payments for this student
        const payments = allPayments.filter(p => String(p.student_id || p.admission_number || p.id) === sid);
        if (!payments || payments.length === 0) { showModalMessage('No payments found for this student'); return; }

        const eligible = payments.filter(p => (p.status || '').toLowerCase() !== 'approved' && canApprovePayment(p).ok);
        if (!eligible.length) { showModalMessage('No eligible payments found to approve for this student'); return; }

        const total = eligible.reduce((s,p) => s + Number(p.amount_paid || p.amount || 0), 0);
        if (!(await showConfirm(`Approve ${eligible.length} payments totalling ${cedis(total)} for ${getFullName(student) || sid}?`, 'Bulk Approve'))) return;

        for (const p of eligible) {
          try {
            if (p.source_table === 'level100payments') {
              await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
            } else if (p.source_table === 'payments') {
              await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
            }
          } catch (e) {
            // ignore table-not-found style errors
            const msg = e?.message || String(e);
            if (!(msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404'))) console.warn('Error updating source table for bulk approve:', e);
          }

          try {
            await upsertCanonicalPayment(p, 'approved');
          } catch (e) {
            console.warn('Could not upsert canonical payment in bulk approve:', e?.message || e);
          }
        }

        // Single notification for all approvals (put in notifications modal)
        try {
          const studentKey = sid;
          const studentName = getFullName(student) || 'Student';
          const message = `Hello ${studentName}, your ${eligible.length} payment(s) totalling ${cedis(total)} have been approved by admin.`;
          await setStudentNotification(studentKey, message, { modalOnly: true, meta: { event: 'payment_approved' } });
          // Attempt to send SMS confirmation to the student (best-effort)
          try {
            // Resolve phone from cache or DB
            let studentRecord = allStudents.find(s => String(s.student_id || s.admission_number || s.id) === sid);
            if (!studentRecord) { allStudents = await fetchAllStudents(); studentRecord = allStudents.find(s => String(s.student_id || s.admission_number || s.id) === sid); }
            let rawPhone = studentRecord?.phone || studentRecord?.phone_number || '';
            if (!rawPhone) {
              try { const { data: sdata } = await sb.from('students').select('phone,phone_number').or(`student_id.eq.${sid},admission_number.eq.${sid}`).limit(1).maybeSingle(); if (sdata) rawPhone = sdata.phone || sdata.phone_number; } catch(_) {}
            }
            function normalizePhoneLocal(phone){ if(!phone) return null; let d=String(phone).replace(/\D/g,''); if(d.charAt(0)==='0') d='233'+d.slice(1); return d.length<9?null:d; }
            const formatted = normalizePhoneLocal(rawPhone);
            if (formatted) {
              await sendViaArkesel([formatted], message, { student_id: sid, bulk_count: eligible.length });
            }
          } catch (smsErr) { console.warn('Could not send approval SMS for bulk approvals:', smsErr); }
        } catch (e) {
          console.warn('Could not set student notification for bulk approve:', e?.message || e);
        }

        // Refresh caches and UI
        allPayments = await fetchAllPayments();
        allStudents = await fetchAllStudents();

        const refreshedStudent = allStudents.find(s => String(s.student_id || s.admission_number || s.id) === sid);
        if (refreshedStudent) renderStudentPaymentsSummary(refreshedStudent);

        showModalMessage(`Approved ${eligible.length} payment(s) and notified the student.`);
      } catch (err) {
        console.error('Error approving all eligible payments:', err);
        showModalMessage('Error approving payments. See console for details.');
      }
    }

    // small debounce helper
    function debounce(fn, wait) {
      let t = null;
      return function(...args) {
        clearTimeout(t);
        t = setTimeout(()=> fn.apply(this, args), wait);
      };
    }

    // escape html to avoid injection in UI
    function escapeHtml(str) {
      if (!str && str !== 0) return '';
      return String(str).replace(/[&<>\"']/g, function(s) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[s];
      });
    }

    // Handle form submission
    document.getElementById('manualPaymentForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      
      // Get form values
      const studentSearch = document.getElementById('studentSearch').value;
      // support multiple selected fee types (checkboxes). If none checked, fallback to paymentType select (legacy)
      const feeCheckboxes = Array.from(document.querySelectorAll('.fee-checkbox'));
      const selectedFees = feeCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

      const paymentType = selectedFees.length ? null : (document.getElementById('paymentType') ? document.getElementById('paymentType').value : 'other');
      const amount = document.getElementById('amount').value;
      const paymentDate = document.getElementById('paymentDate').value;
      // Prefer a manually entered receipt number when provided, otherwise generate a unique base
      const manualReceiptInput = (document.getElementById('receiptNumber') && String(document.getElementById('receiptNumber').value || '').trim()) || '';
      const generatedBase = manualReceiptInput ? `MANUAL-${manualReceiptInput}` : `MANUAL-${Date.now()}-${Math.floor(Math.random()*9000)+1000}`;
      const paymentMethod = document.getElementById('paymentMethod').value;
      const paymentNotes = document.getElementById('paymentNotes').value;
      
      // Validate basic form
      if (!studentSearch || !amount || !paymentDate) {
        showModalMessage('Please fill in Student, Amount and Date');
        return;
      }

      // If no fees selected and no legacy paymentType, require at least one fee
      if ((!selectedFees || selectedFees.length === 0) && (!paymentType || paymentType === '')) {
        showModalMessage('Please select at least one payment type');
        return;
      }

      // Ensure a student is selected (we fetch from Supabase in selectStudent)
      if (!selectedStudent) {
        // Try to extract an ID and fetch student
        const studentMatch = studentSearch.match(/\(([^)]+)\)/);
        const studentIdGuess = studentMatch ? studentMatch[1] : studentSearch.trim();
        if (!studentIdGuess) {
          showModalMessage('Please select a student from the search results');
          return;
        }

        await selectStudent(studentIdGuess);

        if (!selectedStudent) {
          showModalMessage('Student not found in database. Please check the student information.');
          return;
        }
      }

      const student = selectedStudent;
      const studentId = student.student_id || student.admission_number || studentSearch.trim();
      const studentName = getFullName(student) || 'Unknown Student';

      // Prepare payment data(s). If multiple fees are selected, split into separate payment entries.
      // Helper to compute expected amount for a fee key
      function expectedAmountForFee(key){
        key = (key||'').toLowerCase();
        if (key === 'admission') return ADMISSION_FEE;
        if (key === 'tuition') return TUITION_80; // tuition (80%) expected
        if (key === 'tuition100') return TUITION; // tuition (100%) expected
        if (key === 'src') return SRC_DUES;
        if (key === 'departmental') return DEPT_DUES;
        if (key === 'medical') return MED_DUES;
        return 0; // 'other' or unknown
      }

      // Determine entries to insert
      let entries = [];
      if (selectedFees && selectedFees.length) {
        // compute expected totals
        const expectedMap = selectedFees.reduce((acc, k) => { acc[k] = expectedAmountForFee(k); return acc; }, {});
        const sumExpected = Object.values(expectedMap).reduce((s,v) => s + (v||0), 0);
        const totalEntered = Number(amount);

        if (sumExpected === 0) {
          // all selected are 'other' (or no known expected amounts): create single entry with the entered amount
          entries.push({ fee_key: selectedFees[0], amount: totalEntered });
        } else {
          // split amounts proportionally based on expected amounts
          const allocated = {};
          let running = 0;
          selectedFees.forEach((k, idx) => {
            const exp = expectedMap[k] || 0;
            let val = Math.round(((exp / sumExpected) * totalEntered) * 100) / 100;
            // for last item, consume remainder to avoid rounding loss
            if (idx === selectedFees.length - 1) val = Math.round((totalEntered - running) * 100) / 100;
            allocated[k] = val;
            running += val;
          });
          selectedFees.forEach(k => entries.push({ fee_key: k, amount: allocated[k] }));
        }
      } else {
        // single legacy payment type
        const feeKey = paymentType || 'other';
        entries.push({ fee_key: feeKey, amount: Number(amount) });
      }
      // Compute coverage will be calculated per-entry below when building pdata

      // Save each entry sequentially
      const saved = [];
      const failed = [];
      for (const en of entries) {
        try {
          const feeKey = en.fee_key || en.fee_type || 'other';
          const feeLabelMap = { admission: 'Admission Fee', tuition: 'Tuition (80%)', tuition100: 'Tuition (100%)', src: 'SRC Dues', departmental: 'Departmental Dues', medical: 'Medical Dues', other: 'Other' };
          const feeLabel = feeLabelMap[feeKey] || feeKey;

          // compute expected amount for this fee key and coverage metadata
          const expectedForKey = expectedAmountForFee(feeKey);
          let coveragePercent = null;
          let coverageLabel = null;
          const amtForEntry = Number(en.amount || 0);
          if (expectedForKey && expectedForKey > 0) {
            coveragePercent = Math.round((amtForEntry / expectedForKey) * 100);
            if (coveragePercent >= 100) coverageLabel = 'full';
            else if (coveragePercent >= 80) coverageLabel = 'partial_80';
            else if (coveragePercent >= 50) coverageLabel = 'partial_50';
            else coverageLabel = 'partial';
          }

          const pdata = {
            student_id: studentId,
            student_name: studentName,
            student_email: student.email || 'N/A',
            department: student.department || student.program || 'Not assigned',
            level: 'Level 100',
            amount_paid: Number(en.amount || 0),
            fee_type: feeLabel,
            payment_coverage: coverageLabel,
            coverage_percent: coveragePercent,
            transaction_ref: `${generatedBase}-${feeKey.toUpperCase()}`,
            payment_id: `MANUAL-${Date.now()}-${Math.floor(Math.random()*9999)}`,
            payment_date: paymentDate,
            receipt_number: `${generatedBase}-${feeKey.toUpperCase()}`,
            payment_method: paymentMethod,
            notes: paymentNotes,
            status: 'approved',
            reviewed_by: 'Finance Admin',
            reviewed_at: new Date().toISOString()
          };

          const inserted = await recordManualPayment(pdata);
          if (!inserted) { failed.push({ pdata, reason: 'insert failed' }); continue; }

          // upsert canonical
          try { await upsertCanonicalPayment(Object.assign({}, inserted, { source_table: 'level100payments' }), 'approved'); } catch(e){ console.warn('upsert canonical failed', e); }

          // notify student and send sms
          try {
            const studentIdKey = inserted.student_id || inserted.admission_number || studentId;
            const message = `GH TECHNICAL — Hi ${inserted.student_name || 'Student'}, your payment of ${cedis(inserted.amount_paid || 0)} for ${inserted.fee_type || 'fees'} (Ref: ${inserted.transaction_ref || inserted.receipt_number || 'N/A'}) has been received and recorded. Thank you.`;
            await setStudentNotification(studentIdKey, message).catch(()=>{});

            // find phone
            let studentRec = allStudents.find(s => s.student_id === studentIdKey || s.admission_number === studentIdKey || String(s.id) === String(studentIdKey));
            if (!studentRec) {
              try { const { data: sdata } = await sb.from('students').select('phone,phone_number').or(`student_id.eq.${studentIdKey},admission_number.eq.${studentIdKey}`).limit(1).maybeSingle(); if (sdata) studentRec = sdata; } catch(_){ }
            }
            const rawPhone = studentRec?.phone || studentRec?.phone_number || inserted.student_phone || inserted.phone;
            const formattedPhone = normalizePhone(rawPhone);
            if (formattedPhone) {
              try { await sendViaArkesel([formattedPhone], message, { student_id: studentIdKey }); } catch(e){ console.warn('SMS send failed', e); }
            }
          } catch (notifErr) { console.warn('Could not notify student after manual payment:', notifErr); }

          // generate pdf only for single-fee submits; multi-fee combined receipts handled after loop
          try {
            if (!entries || entries.length === 1) {
              generatePdfReceipt(inserted);
            }
          } catch(e){ console.warn('Could not generate PDF receipt:', e); }

          saved.push(inserted);
        } catch (e) {
          console.error('Error saving payment entry', e);
          failed.push({ entry: en, reason: e?.message || String(e) });
        }
      }

      // If multiple fees were saved in one submit, generate a combined receipt (single download)
          if (saved.length > 1) {
        try {
          generatePdfReceiptCombined(saved);
          // persist last combined receipt metadata for re-download
          const base = saved[0].receipt_number ? String(saved[0].receipt_number).split('-')[0] : (saved[0].transaction_ref || saved[0].payment_id || Date.now());
          const filename = `receipt-${base}.pdf`;
          window.__lastCombinedReceipt = { filename: filename, payments: saved };

          // create or update a small re-download area right after the manual form
          try {
            const areaId = 'combinedReceiptArea';
            let area = document.getElementById(areaId);
            if (!area) {
              area = document.createElement('div');
              area.id = areaId;
              area.style.marginTop = '8px';
              const formEl = document.getElementById('manualPaymentForm');
              if (formEl && formEl.parentNode) formEl.parentNode.insertBefore(area, formEl.nextSibling);
            }
            area.innerHTML = `<button id="reDownloadCombinedReceiptBtn" class="btn"><i class="fas fa-download"></i> Re-download last combined receipt</button> <span style="color:var(--gray); margin-left:8px;">Combined receipt generated</span>`;
            const btn = document.getElementById('reDownloadCombinedReceiptBtn');
            if (btn) {
              btn.addEventListener('click', function(){
                if (window.__lastCombinedReceipt && window.__lastCombinedReceipt.payments) {
                  generatePdfReceiptCombined(window.__lastCombinedReceipt.payments);
                } else {
                  showModalMessage('No combined receipt available');
                }
              });
            }
          } catch (uiErr) { console.warn('Could not render combined receipt UI hint', uiErr); }
        } catch (e) {
          console.warn('Could not generate combined PDF for multi-fee submit', e);
        }
      }

      // results
      if (saved.length) {
        showModalMessage(`Recorded ${saved.length} payment(s). ${failed.length ? `${failed.length} failed.` : ''}`);
        resetManualPaymentForm();
        loadManualPayments();
        try { allPayments = await fetchAllPayments(); allStudents = await fetchAllStudents(); } catch(e){}
        try { await upsertCanonicalPayment(Object.assign({}, saved[0], { source_table: 'level100payments' }), 'approved'); } catch(e){}
        loadDashboardData();
      }

      if (failed.length) {
        console.warn('Some entries failed to record:', failed);
        showModalMessage(`Some payments failed during recording. See console for details.`);
      }
    });

    // ----- Batch payments support -----
    const manualPaymentBatch = [];

    function addToBatch() {
      // Ensure a student is selected
      if (!selectedStudent) {
        showModalMessage('Please select a student from the search results before adding to batch');
        return;
      }

      const amount = Number(document.getElementById('amount').value || 0);
      const paymentDate = document.getElementById('paymentDate').value;
      // Prefer manual receiptNumber for batch items if admin entered one, otherwise generate a batch base
      const manualBatchReceipt = (document.getElementById('receiptNumber') && String(document.getElementById('receiptNumber').value || '').trim()) || '';
      const batchBase = manualBatchReceipt ? `MANUAL-${manualBatchReceipt}` : `MANUAL-${Date.now()}-${Math.floor(Math.random()*9000)+1000}`;
      const paymentMethod = document.getElementById('paymentMethod').value;
      const paymentNotes = document.getElementById('paymentNotes').value;

      if (!amount || !paymentDate) {
        showModalMessage('Please fill in Amount and Date before adding to batch');
        return;
      }

      // Collect selected fees
      const feeCheckboxes = Array.from(document.querySelectorAll('.fee-checkbox'));
      const selectedFees = feeCheckboxes.filter(cb => cb.checked).map(cb => cb.value);

      // Fallback: if no checkboxes selected, look for legacy paymentType element
      if (!selectedFees.length) {
        const paymentTypeEl = document.getElementById('paymentType');
        if (paymentTypeEl && paymentTypeEl.value) selectedFees.push(paymentTypeEl.value);
      }

      if (!selectedFees.length) {
        showModalMessage('Please select at least one fee type before adding to batch');
        return;
      }

      function expectedAmountForFeeLocal(key){
        if(!key) return 0;
        key = key.toLowerCase();
        if (key === 'admission') return ADMISSION_FEE;
        if (key === 'tuition') return TUITION_80;
        if (key === 'tuition100') return TUITION;
        if (key === 'src') return SRC_DUES;
        if (key === 'departmental') return DEPT_DUES;
        if (key === 'medical') return MED_DUES;
        return 0;
      }

      // compute expected totals
      const expectedMap = selectedFees.reduce((acc, k) => { acc[k] = expectedAmountForFeeLocal(k); return acc; }, {});
      const sumExpected = Object.values(expectedMap).reduce((s,v) => s + (v||0), 0);
      const totalEntered = amount;

      const entriesToAdd = [];
      const feeLabelMapLocal = { admission: 'Admission Fee', tuition: 'Tuition (80%)', tuition100: 'Tuition (100%)', src: 'SRC Dues', departmental: 'Departmental Dues', medical: 'Medical Dues', other: 'Other' };
      if (sumExpected === 0) {
        // unknown expected amounts (likely 'other') — create single entry per selected fee with entered amount split equally
        const per = Math.round((totalEntered / selectedFees.length) * 100) / 100;
        selectedFees.forEach((k, idx) => {
          const receiptSuffix = k.toUpperCase();
          entriesToAdd.push({
            student_id: selectedStudent.student_id || selectedStudent.admission_number || selectedStudent.id || '',
            student_name: getFullName(selectedStudent) || selectedStudent.full_name || selectedStudent.name || '',
            student_email: selectedStudent.email || '',
            department: selectedStudent.department || selectedStudent.program || '',
            level: 'Level 100',
            amount_paid: per,
            fee_type: feeLabelMapLocal[k] || k,
            transaction_ref: `${batchBase}-${receiptSuffix}`,
            payment_id: `MANUAL-${Date.now()}-${Math.floor(Math.random()*9999)}`,
            payment_date: paymentDate,
            receipt_number: `${batchBase}-${receiptSuffix}`,
            payment_method: paymentMethod,
            notes: paymentNotes,
            status: 'approved',
            reviewed_by: 'Finance Admin',
            reviewed_at: new Date().toISOString()
          });
        });
      } else {
        // allocate proportionally based on expected amounts
        let running = 0;
        selectedFees.forEach((k, idx) => {
          const exp = expectedMap[k] || 0;
          let val = Math.round(((exp / sumExpected) * totalEntered) * 100) / 100;
          if (idx === selectedFees.length - 1) val = Math.round((totalEntered - running) * 100) / 100;
          running += val;
          const receiptSuffix = k.toUpperCase();
          entriesToAdd.push({
            student_id: selectedStudent.student_id || selectedStudent.admission_number || selectedStudent.id || '',
            student_name: getFullName(selectedStudent) || selectedStudent.full_name || selectedStudent.name || '',
            student_email: selectedStudent.email || '',
            department: selectedStudent.department || selectedStudent.program || '',
            level: 'Level 100',
            amount_paid: val,
            fee_type: feeLabelMapLocal[k] || k,
            transaction_ref: `${batchBase}-${receiptSuffix}`,
            payment_id: `MANUAL-${Date.now()}-${Math.floor(Math.random()*9999)}`,
            payment_date: paymentDate,
            receipt_number: `${batchBase}-${receiptSuffix}`,
            payment_method: paymentMethod,
            notes: paymentNotes,
            status: 'approved',
            reviewed_by: 'Finance Admin',
            reviewed_at: new Date().toISOString()
          });
        });
      }

      // push all generated entries into the batch
      entriesToAdd.forEach(it => manualPaymentBatch.push(it));
      renderBatchTable();

      // Show batch controls
      document.getElementById('manualPaymentBatch').style.display = 'block';
      const recBtn = document.getElementById('recordBatchBtn');
      const clrBtn = document.getElementById('clearBatchBtn');
      if (recBtn) recBtn.style.display = 'inline-block';
      if (clrBtn) clrBtn.style.display = 'inline-block';

      showModalMessage(`Added ${entriesToAdd.length} payment item(s) to the batch.`);
    }

    function renderBatchTable() {
      const tbody = document.querySelector('#manualPaymentBatchTable tbody');
      if (!tbody) return;
      if (!manualPaymentBatch.length) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; color:var(--gray);">No batch items</td></tr>';
        document.getElementById('manualPaymentBatch').style.display = 'none';
        const recBtn = document.getElementById('recordBatchBtn');
        const clrBtn = document.getElementById('clearBatchBtn');
        if (recBtn) recBtn.style.display = 'none';
        if (clrBtn) clrBtn.style.display = 'none';
        return;
      }

      let html = '';
      manualPaymentBatch.forEach((it, idx) => {
        html += `
          <tr>
            <td>${idx+1}</td>
            <td>${escapeHtml(it.student_id)}</td>
            <td>${escapeHtml(it.student_name)}</td>
            <td>${escapeHtml(it.fee_type)}</td>
            <td>${cedis(it.amount_paid || 0)}</td>
            <td>${escapeHtml(it.receipt_number || '')}</td>
            <td>
              <button class="btn btn-sm" onclick="removeBatchItem(${idx})">Remove</button>
            </td>
          </tr>
        `;
      });

      tbody.innerHTML = html;
    }

    function removeBatchItem(index) {
      if (index < 0 || index >= manualPaymentBatch.length) return;
      manualPaymentBatch.splice(index, 1);
      renderBatchTable();
    }

    async function clearBatch() {
      if (!manualPaymentBatch.length) return;
      if (!(await showConfirm('Clear all items from the batch?', 'Clear Batch'))) return;
      manualPaymentBatch.length = 0;
      renderBatchTable();
      showModalMessage('Batch cleared');
    }

    async function processBatchPayments() {
      if (!manualPaymentBatch.length) { showModalMessage('No payments in batch'); return; }
      if (!(await showConfirm(`Record ${manualPaymentBatch.length} payments now?`, 'Confirm Batch Submit'))) return;

      const results = { success: [], failed: [] };
      // disable buttons while processing
      const recBtn = document.getElementById('recordBatchBtn');
      const clrBtn = document.getElementById('clearBatchBtn');
      if (recBtn) recBtn.disabled = true;
      if (clrBtn) clrBtn.disabled = true;

      for (const item of manualPaymentBatch) {
        try {
          // insert into level100payments
          const inserted = await recordManualPayment(item);
          if (!inserted) {
            results.failed.push({ item, reason: 'Insert failed' });
            continue;
          }

          // Upsert canonical payments table
          try { await upsertCanonicalPayment(Object.assign({}, inserted, { source_table: 'level100payments' }), 'approved'); } catch(e){ console.warn('upsert canonical failed for batch item', e); }

          // Notify student record and send SMS (best-effort)
          try {
            const studentIdKey = inserted.student_id || inserted.admission_number || item.student_id;
            const message = `GH TECHNICAL — Hi ${inserted.student_name || 'Student'}, your payment of ${cedis(inserted.amount_paid || 0)} for ${inserted.fee_type || 'fees'} (Ref: ${inserted.transaction_ref || inserted.receipt_number || 'N/A'}) has been received and recorded. Thank you.`;
            await setStudentNotification(studentIdKey, message).catch(()=>{});

            // find phone from cache or DB
            let studentRec = allStudents.find(s => s.student_id === studentIdKey || s.admission_number === studentIdKey || String(s.id) === String(studentIdKey));
            if (!studentRec) {
              try { const { data: sdata } = await sb.from('students').select('phone,phone_number').or(`student_id.eq.${studentIdKey},admission_number.eq.${studentIdKey}`).limit(1).maybeSingle(); if (sdata) studentRec = sdata; } catch(_){ }
            }

            const rawPhone = studentRec?.phone || studentRec?.phone_number || inserted.student_phone || inserted.phone;
            const formattedPhone = normalizePhone(rawPhone);
            if (formattedPhone) {
              try { await sendViaArkesel([formattedPhone], message, { student_id: studentIdKey }); } catch(e){ console.warn('SMS send failed for batch item', e); }
            }
          } catch (notifErr) { console.warn('Post-insert notification failed for batch item', notifErr); }

          // Generate PDF receipt
          try { generatePdfReceipt(inserted); } catch(e){ console.warn('Could not generate PDF for batch item', e); }

          results.success.push({ item, inserted });
        } catch (e) {
          console.error('Batch item failed', e);
          results.failed.push({ item, reason: e?.message || String(e) });
        }
      }

      // Re-enable buttons
      if (recBtn) recBtn.disabled = false;
      if (clrBtn) clrBtn.disabled = false;

      // Refresh caches and UI
      try {
        allPayments = await fetchAllPayments();
        allStudents = await fetchAllStudents();
        loadManualPayments();
        loadDashboardData();
      } catch (e) { console.warn('Could not refresh caches after batch', e); }

      // Show summary
      const msg = `Batch completed. Success: ${results.success.length}. Failed: ${results.failed.length}.`;
      showModalMessage(msg, 'Batch Result');

      // If there were failures, include details in console and modal if few
      if (results.failed.length) console.warn('Batch failures:', results.failed);

      // Clear successful items from batch, leave failed ones for review
      if (results.failed.length === 0) {
        manualPaymentBatch.length = 0;
        renderBatchTable();
      } else {
        // keep only failed items
        const failedItems = results.failed.map(f => f.item);
        manualPaymentBatch.length = 0;
        Array.prototype.push.apply(manualPaymentBatch, failedItems);
        renderBatchTable();
      }
    }

    async function loadManualPayments(searchTerm) {
      // Filter manual payments (those with payment_method = 'manual')
      const term = (searchTerm || '').toString().toLowerCase().trim();
      let manualPayments = allPayments.filter(p => p.payment_method === 'manual');
      if (term) {
        manualPayments = manualPayments.filter(p => {
          const candidates = [p.transaction_ref, p.receipt_number, p.student_id, p.admission_number, p.student_name, p.fee_type, p.payment_id, p.student_email, p.phone];
          return candidates.some(c => ('' + (c || '')).toLowerCase().includes(term));
        });
      }
      
      const manualPaymentsTable = document.getElementById('manualPaymentsTable');
      if (manualPaymentsTable) {
        let html = '';
        
        manualPayments.forEach(payment => {
          const statusClass = payment.status === 'approved' ? 'status-approved' : 
                             payment.status === 'rejected' ? 'status-rejected' : 'status-pending';
          
          const statusText = payment.status === 'approved' ? 'Approved' : 
                            payment.status === 'rejected' ? 'Rejected' : 'Pending Review';

          html += `
            <tr>
              <td>${payment.student_name || 'Unknown Student'} (${payment.student_id || 'N/A'})</td>
              <td>${payment.fee_type || 'Unknown Fee'}</td>
              <td>${cedis(payment.amount_paid || 0)}</td>
              <td>${formatDate(payment.payment_date || payment.created_at)}</td>
              <td>${payment.receipt_number || 'N/A'}</td>
              <td><span class="status-badge ${statusClass}">${statusText}</span></td>
              <td>
                <div class="action-group">
                  <button class="btn btn-sm" onclick="viewPaymentForApproval('${payment.id}')">
                    <i class="fas fa-eye"></i> View
                  </button>
                  <button class="btn btn-sm" onclick="generatePdfReceiptById('${escapeHtml(payment.id || payment.payment_id || payment.transaction_ref || '')}')">
                    <i class="fas fa-download"></i> Receipt
                  </button>
                  ${payment.status !== 'approved' ? `` : `
                  <button class="btn btn-sm btn-warning" onclick="revokePayment('${payment.id}')">
                    <i class="fas fa-undo"></i> Revoke
                  </button>`}
                  <button class="btn btn-sm btn-danger" onclick="deleteManualPayment('${escapeHtml(payment.id || payment.payment_id || '')}')">
                    <i class="fas fa-trash"></i> Delete
                  </button>
                  <button class="btn btn-sm btn-danger" style="background:#c41f1f;" onclick="softDeleteStudent('${escapeHtml(payment.student_id || payment.admission_number || payment.studentId || '')}')">
                    <i class="fas fa-user-slash"></i> Delete Student
                  </button>
                </div>
              </td>
            </tr>
          `;
        });

        if (manualPayments.length === 0) {
          html = `<tr><td colspan="7" style="text-align: center; padding: 20px;">No manual payments found</td></tr>`;
        }

        manualPaymentsTable.innerHTML = html;
      }
    }

    /* -------------- PAYMENT REVIEW -------------- */
    function loadPaymentReviewData() {
      // Set up subtabs
      document.querySelectorAll('[data-subtab]').forEach(tab => {
        tab.addEventListener('click', function() {
          const subtabName = this.dataset.subtab;
          
          // Update tabs
          document.querySelectorAll('[data-subtab]').forEach(t => {
            t.classList.remove('active');
          });
          this.classList.add('active');
          
          // Update tab contents
          document.querySelectorAll('.tab-content').forEach(content => {
            if (content.id.includes('subtab')) {
              content.classList.remove('active');
            }
          });
          document.getElementById(`${subtabName}-subtab`).classList.add('active');
        });
      });

      // Load real data for each subtab
      const pendingPayments = allPayments.filter(p => p.status === 'pending');
      const approvedPayments = allPayments.filter(p => p.status === 'approved');
      const rejectedPayments = allPayments.filter(p => p.status === 'rejected');

      // Pending Payments Table with multi-select and bulk actions
      let pendingHtml = '';
      pendingHtml += `
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
          <label style="display:flex;align-items:center;gap:8px;margin:0;">
            <input type="checkbox" id="pendingSelectAll" onchange="toggleSelectAllPending(this)" /> Select All
          </label>
          <!-- Approve buttons removed from UI -->
          <div style="margin-left:auto;color:var(--gray);font-size:0.9rem;">Total pending: ${pendingPayments.length}</div>
        </div>
      `;

      pendingPayments.forEach(payment => {
        const pid = payment.id || payment.payment_id || payment.transaction_ref || '';
        pendingHtml += `
          <tr>
            <td style="width:40px;"><input type="checkbox" class="pending-checkbox" data-payment-id="${pid}" /></td>
            <td>${payment.student_name || 'Unknown Student'} (${payment.student_id || 'N/A'})</td>
            <td>${payment.fee_type || 'Unknown Fee'}</td>
            <td>${cedis(payment.amount_paid || 0)}</td>
            <td>${formatDate(payment.payment_date || payment.created_at)}</td>
            <td>${payment.payment_method || 'N/A'}</td>
            <td>${payment.receipt_number || payment.transaction_ref || 'N/A'}</td>
            <td>
              <button class="btn btn-sm" onclick="viewPaymentForApproval('${pid}')">
                <i class="fas fa-eye"></i> Review
              </button>
            </td>
          </tr>
        `;
      });

      if (pendingPayments.length === 0) {
        pendingHtml = `<tr><td colspan="7" style="text-align: center; padding: 20px;">No pending payments</td></tr>`;
      }
      document.getElementById('pendingPaymentsTable').innerHTML = pendingHtml;

      // Approved Payments Table
      let approvedHtml = '';
      approvedPayments.forEach(payment => {
        approvedHtml += `
          <tr>
            <td>${payment.student_name || 'Unknown Student'} (${payment.student_id || 'N/A'})</td>
            <td>${payment.fee_type || 'Unknown Fee'}</td>
            <td>${cedis(payment.amount_paid || 0)}</td>
            <td>${formatDate(payment.payment_date || payment.created_at)}</td>
            <td>${payment.reviewed_by || 'Finance Admin'}</td>
            <td>
              <button class="btn btn-sm btn-danger" onclick="revokePayment('${payment.id}')">
                <i class="fas fa-undo"></i> Revoke
              </button>
            </td>
          </tr>
        `;
      });

      if (approvedPayments.length === 0) {
        approvedHtml = `<tr><td colspan="6" style="text-align: center; padding: 20px;">No approved payments</td></tr>`;
      }
      document.getElementById('approvedPaymentsTable').innerHTML = approvedHtml;

      // Rejected Payments Table
      let rejectedHtml = '';
      rejectedPayments.forEach(payment => {
        rejectedHtml += `
          <tr>
            <td>${payment.student_name || 'Unknown Student'} (${payment.student_id || 'N/A'})</td>
            <td>${payment.fee_type || 'Unknown Fee'}</td>
            <td>${cedis(payment.amount_paid || 0)}</td>
            <td>${formatDate(payment.payment_date || payment.created_at)}</td>
            <td>${payment.admin_notes || 'No reason provided'}</td>
            <td>
              <button class="btn btn-sm" onclick="viewPaymentForApproval('${payment.id}')">
                <i class="fas fa-eye"></i> View
              </button>
            </td>
          </tr>
        `;
      });

      if (rejectedPayments.length === 0) {
        rejectedHtml = `<tr><td colspan="6" style="text-align: center; padding: 20px;">No rejected payments</td></tr>`;
      }
      document.getElementById('rejectedPaymentsTable').innerHTML = rejectedHtml;
    }

    async function viewPaymentForApproval(paymentId) {
      currentPaymentId = paymentId;

      // Try to find the payment in the client cache first by several keys
      let payment = (allPayments || []).find(p => {
        if (!p) return false;
        const pid = String(paymentId || '');
        return String(p.id || '') === pid || String(p.payment_id || '') === pid || String(p.transaction_ref || '') === pid || String(p.receipt_number || '') === pid;
      });

      // If not found in cache, try to fetch from likely tables (`level100payments`, `payments`)
      if (!payment) {
        try {
          const q = String(paymentId || '');
          const orClause = `id.eq.${q},payment_id.eq.${q},transaction_ref.eq.${q},receipt_number.eq.${q}`;

          // Try level100payments
          try {
            const { data: p1, error: e1 } = await sb.from('level100payments').select('*').or(orClause).limit(1).maybeSingle();
            if (!e1 && p1) payment = Object.assign({}, p1, { source_table: 'level100payments' });
          } catch (e) { /* ignore table-not-found errors */ }

          // Try canonical payments table if still not found
          if (!payment) {
            try {
              const { data: p2, error: e2 } = await sb.from('payments').select('*').or(orClause).limit(1).maybeSingle();
              if (!e2 && p2) payment = Object.assign({}, p2, { source_table: 'payments' });
            } catch (e) { /* ignore */ }
          }
        } catch (e) {
          console.warn('Could not query payment tables for review:', e);
        }
      }

      // If still not found, show student search instead of error — populate modal with whatever we can
      if (!payment) {
        // Try to interpret the id as a student id and open student details instead
        try {
          const sid = String(paymentId || '').trim();
          if (sid) {
            await selectStudent(sid);
            // Open student detail modal if available
            if (document.getElementById('studentDetailModal')) openModal('studentDetailModal');
            else showModalMessage('Payment not found but student details opened (if available).');
            return;
          }
        } catch (e) {
          console.warn('Fallback student lookup failed', e);
        }

        showModalMessage('Payment not found');
        return;
      }

      // Ensure currentPaymentId points to an identifier we can use
      currentPaymentId = payment.id || payment.payment_id || payment.transaction_ref || currentPaymentId;

      // Find student information in cache, otherwise try fetching from Supabase
      let student = (allStudents || []).find(s => {
        const key = payment.student_id || payment.admission_number || payment.studentId || payment.student_id;
        return s && (String(s.student_id) === String(key) || String(s.admission_number) === String(key) || String(s.id) === String(key));
      });

      if (!student) {
        const candidateTables = ['students', 'newstudents'];
        for (const table of candidateTables) {
          try {
            const q = (payment.student_id || payment.admission_number || payment.studentId || payment.student_email || '').toString();
            if (!q) continue;
            const { data: sdata, error: serr } = await sb.from(table)
              .select('*')
              .or(`student_id.eq.${q},admission_number.eq.${q},email.eq.${q}`)
              .limit(1)
              .maybeSingle();
            if (!serr && sdata) { student = sdata; student.source_table = table; break; }
          } catch (e) {
            const msg = e?.message || String(e);
            if (msg && (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404'))) continue;
            console.warn('Error fetching student for payment review from', table, e);
          }
        }
      }

      // Update student details (use payment fields as fallback)
      document.getElementById('studentDetails').innerHTML = `
        <div class="student-detail-item">
          <div class="student-detail-label">Student ID</div>
          <div class="student-detail-value">${escapeHtml(payment.student_id || payment.admission_number || payment.studentId || 'N/A')}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Student Name</div>
          <div class="student-detail-value">${escapeHtml(payment.student_name || (student && getFullName(student)) || 'Unknown Student')}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Email</div>
          <div class="student-detail-value">${escapeHtml(payment.student_email || (student && (student.email || student.contact_email)) || 'N/A')}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Phone</div>
          <div class="student-detail-value">${escapeHtml((student && (student.phone || student.phone_number)) || payment.student_phone || payment.phone || 'N/A')}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Department</div>
          <div class="student-detail-value">${escapeHtml(payment.department || (student && (student.department || student.program)) || 'Not assigned')}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Level</div>
          <div class="student-detail-value">${escapeHtml(payment.level || 'Level 100')}</div>
        </div>
      `;

      // Update payment details
      document.getElementById('paymentDetails').innerHTML = `
        <div class="payment-info-item">
          <div class="payment-info-label">Payment ID</div>
          <div class="payment-info-value">${escapeHtml(payment.payment_id || payment.id || '') || 'N/A'}</div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Fee Type</div>
          <div class="payment-info-value">${escapeHtml(payment.fee_type || payment.payment_type || 'Unknown Fee')}</div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Amount Paid</div>
          <div class="payment-info-value">${cedis(payment.amount_paid || payment.amount || 0)}</div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Payment Method</div>
          <div class="payment-info-value">${escapeHtml(payment.payment_method || 'N/A')}</div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Receipt Number</div>
          <div class="payment-info-value">${escapeHtml(payment.receipt_number || payment.transaction_ref || 'N/A')}</div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Payment Date</div>
          <div class="payment-info-value">${formatDateTime(payment.payment_date || payment.created_at)}</div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Status</div>
          <div class="payment-info-value">
            <span class="status-badge ${payment.status === 'approved' ? 'status-approved' : payment.status === 'rejected' ? 'status-rejected' : 'status-pending'}">
              ${payment.status === 'approved' ? 'Approved' : payment.status === 'rejected' ? 'Rejected' : 'Pending Review'}
            </span>
          </div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Coverage</div>
          <div class="payment-info-value">${escapeHtml(payment.payment_coverage || (payment.coverage_percent ? String(payment.coverage_percent) + '%' : 'N/A'))}</div>
        </div>
      `;

      // Update eligibility status (use payment.student_id if available)
      updateEligibilityDisplay(payment.student_id || payment.admission_number || payment.studentId, 'studentEligibilityStatus');

      // Update receipt preview
      document.getElementById('receiptPreview').innerHTML = `
        <h4>Payment Receipt</h4>
        <div class="receipt-placeholder">
          <i class="fas fa-receipt" style="font-size: 3rem; margin-bottom: 16px;"></i>
          <p>${payment.payment_method === 'manual' ? 'Manual payment receipt' : 'Digital payment receipt'}</p>
          <p>${payment.receipt_number ? `Receipt Number: ${escapeHtml(payment.receipt_number)}` : `Transaction ID: ${escapeHtml(payment.transaction_ref || '') || 'N/A'}`}</p>
          <button class="btn" style="margin-top: 16px;" onclick="generateReceiptById('${escapeHtml(currentPaymentId || '')}')">
            <i class="fas fa-download"></i> Download Receipt
          </button>
        </div>
      `;

      // Render the student's full payments list in this modal
      try {
        const paymentsContainer = document.getElementById('paymentDetailStudentPayments');
        if (paymentsContainer) {
          const key = String(payment.student_id || payment.admission_number || payment.studentId || '');
          const payments = (allPayments || []).filter(p => {
            const candidates = [p.student_id, p.admission_number, p.studentId, p.admissionNumber, p.id, p.email, p.customer_email];
            return candidates.some(c => String(c || '') === key);
          }).sort((a,b)=> new Date(b.created_at||b.payment_date||0) - new Date(a.created_at||a.payment_date||0));

          if (!payments || payments.length === 0) {
            paymentsContainer.innerHTML = '<div style="color:var(--gray);">No payments recorded for this student.</div>';
          } else {
            // detect grouped payments that share a receipt/transaction base (e.g., MANUAL-12345-TUITION, MANUAL-12345-ADMISSION)
            try {
              const baseCandidate = String(payment.receipt_number || payment.transaction_ref || '');
              let baseKey = baseCandidate;
              if (baseCandidate && baseCandidate.indexOf('-') !== -1) baseKey = baseCandidate.split('-').slice(0, -1).join('-');
              const grouped = payments.filter(p => {
                const r = String(p.receipt_number || p.transaction_ref || '');
                if (!r) return false;
                return (baseKey && (r.startsWith(baseKey) || r === baseCandidate));
              });
              if (grouped && grouped.length > 1) {
                currentPaymentGroup = grouped;
                const approveBtn = document.getElementById('approvePaymentBtn');
                if (approveBtn) approveBtn.textContent = `Approve ${grouped.length} Items`;
              } else {
                currentPaymentGroup = [];
                const approveBtn = document.getElementById('approvePaymentBtn');
                if (approveBtn) approveBtn.textContent = 'Approve Payment';
              }
            } catch(e) { console.warn('Grouping detection failed', e); }

            let ph = `<div class="table-responsive"><table class="table"><thead><tr><th>Date</th><th>Type</th><th>Amount</th><th>Coverage</th><th>Status</th><th>Ref</th></tr></thead><tbody>`;
            payments.forEach(p => {
              const status = (p.status || 'pending');
              const coverageLabel = p.payment_coverage || (p.coverage_percent ? (p.coverage_percent >= 100 ? 'full' : p.coverage_percent + '%') : 'n/a');
              ph += `<tr><td>${formatDate(p.created_at||p.payment_date||'')}</td><td>${escapeHtml(p.fee_type||p.description||'Other')}</td><td>${cedis(p.amount_paid||p.amount||0)}</td><td>${escapeHtml(String(coverageLabel))}</td><td><span class="status-badge">${escapeHtml(status)}</span></td><td>${escapeHtml(p.transaction_ref||p.receipt_number||p.id||'')}</td></tr>`;
            });
            ph += `</tbody></table></div>`;
            paymentsContainer.innerHTML = ph;
          }
        }
      } catch (e) { console.warn('Could not render payments list in payment modal', e); }

      // Update modal buttons based on status
      const approveBtn = document.getElementById('approvePaymentBtn');
      const rejectBtn = document.getElementById('rejectPaymentBtn');

      // Toggle select-all handler for pending payments (defined near top-level so available)
      window.toggleSelectAllPending = function(cb){
        try {
          const checks = Array.from(document.querySelectorAll('.pending-checkbox'));
          checks.forEach(c => { c.checked = !!cb.checked; });
        } catch(e){ console.warn('toggleSelectAllPending', e); }
      }

      // Approve selected pending payments (bulk)
      window.approveSelectedPending = async function(){
        try {
          const boxes = Array.from(document.querySelectorAll('.pending-checkbox')).filter(b => b.checked);
          if (!boxes.length) return showModalMessage('No payments selected');
          // Resolve payment ids and find payments in cache
          const ids = boxes.map(b => String(b.dataset.paymentId || '').trim()).filter(Boolean);
          if (!ids.length) return showModalMessage('No valid payment ids selected');

          // Refresh caches
          allPayments = await fetchAllPayments();
          allStudents = await fetchAllStudents();

          const selected = ids.map(id => allPayments.find(p => String(p.id || p.payment_id || p.transaction_ref || '') === id)).filter(Boolean);
          if (!selected.length) return showModalMessage('Selected payments not found in cache. Refresh and try again.');

          // Compute totals and eligibility
          const total = selected.reduce((s,p) => s + Number(p.amount_paid || p.amount || 0), 0);
          const eligCount = selected.filter(p => canApprovePayment(p).ok).length;
          const ineligCount = selected.length - eligCount;

          let confirmMsg = `Approve ${selected.length} payment(s) totalling ${cedis(total)}?`;
          if (ineligCount) confirmMsg += `\nNote: ${ineligCount} item(s) may not meet expected amounts and will be approved anyway.`;
          if (!(await showConfirm(confirmMsg, 'Approve Selected Payments'))) return;

          // Group by source table and update
          let approved = 0;
          const byStudent = new Map();
          for (const p of selected) {
            try {
              if (p.source_table === 'level100payments') {
                await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
              } else if (p.source_table === 'payments') {
                await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
              } else {
                try { await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id); } catch(e){}
                try { await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id); } catch(e){}
              }

              try { await upsertCanonicalPayment(p, 'approved'); } catch(e){}
              approved++;

              // aggregate for notification by student
              const key = p.student_id || p.admission_number || p.studentId || p.student_email || 'unknown';
              if (!byStudent.has(key)) byStudent.set(key, []);
              byStudent.get(key).push(p);
            } catch (e) {
              console.warn('approveSelectedPending: failed for', p, e);
            }
          }

          // Notify students (best-effort) grouped per student
          for (const [sid, items] of byStudent.entries()) {
            try {
              const student = allStudents.find(s => String(s.student_id || s.admission_number || s.id) === String(sid));
              const totalForStudent = items.reduce((s,p) => s + Number(p.amount_paid || p.amount || 0), 0);
              const message = `GH TECHNICAL — Hi ${getFullName(student) || 'Student'}, ${items.length} payment(s) totalling ${cedis(totalForStudent)} have been approved.`;
              await setStudentNotification(sid, message, { meta: { event: 'payment_approved', count: items.length } }).catch(()=>{});
              // attempt SMS
              try {
                let rawPhone = (student && (student.phone || student.phone_number)) || items[0].student_phone || items[0].phone || '';
                function normalize(phone){ if(!phone) return null; let d = String(phone).replace(/\D/g,''); if (d.charAt(0)==='0') d='233'+d.slice(1); return d.length<9?null:d; }
                const formatted = normalize(rawPhone);
                if (formatted) await sendViaArkesel([formatted], message, { student_id: sid });
              } catch(e){ console.warn('SMS notify failed for', sid, e); }
            } catch(e){ console.warn('bulk notify error', e); }
          }

          // Refresh UI
          allPayments = await fetchAllPayments();
          allStudents = await fetchAllStudents();
          loadPaymentReviewData();
          showModalMessage(`Approved ${approved} payment(s).`);
        } catch (e) { console.error('approveSelectedPending error', e); showModalMessage('Could not approve selected payments. See console.'); }
      }

      // Approve all pending payments (best-effort, limited)
      window.approveAllPending = async function(){
        try {
          allPayments = await fetchAllPayments();
          allStudents = await fetchAllStudents();
          const pending = (allPayments || []).filter(p => (p.status||'').toString().toLowerCase() === 'pending');
          if (!pending.length) return showModalMessage('No pending payments found');
          const total = pending.reduce((s,p) => s + Number(p.amount_paid || p.amount || 0), 0);
          if (!(await showConfirm(`Approve ALL pending payments (${pending.length}) totalling ${cedis(total)}?`, 'Approve All Pending'))) return;

          // limit to 200 to avoid accidental huge runs
          const batch = pending.slice(0, 200);
          let approved = 0;
          for (const p of batch) {
            try {
              if (p.source_table === 'level100payments') await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
              else if (p.source_table === 'payments') await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
              else { try { await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id); } catch(e){}; try { await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id); } catch(e){} }
              try { await upsertCanonicalPayment(p, 'approved'); } catch(e){}
              approved++;
            } catch(e){ console.warn('approveAllPending: error approving', p, e); }
          }

          allPayments = await fetchAllPayments(); allStudents = await fetchAllStudents();
          loadPaymentReviewData();
          showModalMessage(`Approved ${approved} pending payment(s).`);
        } catch(e){ console.error('approveAllPending error', e); showModalMessage('Could not auto-approve all pending payments. See console.'); }
      }
      
      if (payment.status === 'pending') {
        approveBtn.style.display = 'inline-block';
        rejectBtn.style.display = 'inline-block';
      } else {
        approveBtn.style.display = 'none';
        rejectBtn.style.display = 'none';
      }

      // Clear previous notes
      document.getElementById('adminNotes').value = payment.admin_notes || '';

      openModal('paymentDetailModal');
    }

    async function approvePayment() {
      if (!currentPaymentId && (!currentPaymentGroup || currentPaymentGroup.length === 0)) return;

      const adminNotes = document.getElementById('adminNotes').value;
      const sendSms = document.getElementById('sendSms').checked;

      // Determine group to approve
      const group = (currentPaymentGroup && currentPaymentGroup.length > 0) ? currentPaymentGroup : (function(){ const p = allPayments.find(x => x.id === currentPaymentId || x.payment_id === currentPaymentId || x.transaction_ref === currentPaymentId); return p ? [p] : []; })();
      if (!group.length) { showModalMessage('No payments found to approve'); return; }

      let total = 0;
      let approvedCount = 0;
      const failed = [];

      // Process each component payment in the group
      for (const p of group) {
        try {
          // Update source table when possible
          try {
            if (p.source_table === 'level100payments') {
              await sb.from('level100payments').update({ status: 'approved', admin_notes: adminNotes, reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
            } else if (p.source_table === 'payments') {
              await sb.from('payments').update({ status: 'approved', admin_notes: adminNotes, reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id);
            } else {
              // best-effort: try level100payments by id
              try { await sb.from('level100payments').update({ status: 'approved', admin_notes: adminNotes, reviewed_at: new Date().toISOString(), reviewed_by: 'Finance Admin' }).eq('id', p.id); } catch(e){}
            }
          } catch(e){ /* ignore table-not-found */ }

          // Ensure canonical payments updated
          try { await upsertCanonicalPayment(p, 'approved'); } catch(e){ console.warn('upsert canonical failed for grouped approval', e); }

          approvedCount++; total += Number(p.amount_paid || p.amount || 0);
        } catch (e) {
          failed.push({ payment: p, reason: e?.message || String(e) });
        }
      }

      // Send a single notification for the whole group
      try {
        const studentKey = group[0].student_id || group[0].admission_number || group[0].studentId;
        const studentName = group[0].student_name || getFullName(allStudents.find(s => (s.student_id || s.admission_number) === studentKey) || {} ) || 'Student';
        const message = approvedCount > 1
          ? `Hello ${studentName}, ${approvedCount} payment item(s) totalling ${cedis(total)} have been approved by admin. Thank you.`
          : `GH TECHNICAL — Hi ${studentName}, your payment of ${cedis(total)} for ${group[0].fee_type || 'fees'} (Ref: ${group[0].transaction_ref || group[0].receipt_number || 'N/A'}) has been approved. Thank you.`;
        await setStudentNotification(studentKey, message, { modalOnly: true, meta: { event: 'payment_approved', grouped: approvedCount > 1, count: approvedCount } });
        // populate approval modal content
        document.getElementById('approvedStudentName').textContent = studentName;
        document.getElementById('approvedAmount').textContent = cedis(total);
        document.getElementById('approvedPaymentType').textContent = approvedCount > 1 ? `${approvedCount} item(s)` : (group[0].fee_type || 'Unknown Fee');
        document.getElementById('approvalMessage').textContent = approvedCount > 1 ? `Your ${approvedCount} payment item(s) totalling ${cedis(total)} have been approved.` : document.getElementById('approvalMessage').textContent;
      } catch (e) {
        console.warn('Could not set student notification for grouped approve:', e);
      }

      // Refresh caches and UI
      try { allPayments = await fetchAllPayments(); allStudents = await fetchAllStudents(); } catch(e) { console.warn('Refresh after grouped approval failed', e); }
      loadPaymentReviewData();
      loadDashboardData();

      closeModal('paymentDetailModal');
      openModal('paymentApprovalModal');

      if (sendSms) {
        // For grouped approvals, send a single SMS summary if possible
        try {
          const phoneCandidate = group[0].student_phone || group[0].phone || (allStudents.find(s=> (s.student_id||s.admission_number) === (group[0].student_id||group[0].admission_number)) || {}).phone || (allStudents.find(s=> (s.student_id||s.admission_number) === (group[0].student_id||group[0].admission_number)) || {}).phone_number;
          const formatted = normalizePhone(phoneCandidate);
          if (formatted) {
            const sms = approvedCount > 1
              ? `GH TECHNICAL — Hi ${group[0].student_name || 'Student'}, ${approvedCount} payment item(s) totalling ${cedis(total)} have been approved. Thank you.`
              : `GH TECHNICAL — Hi ${group[0].student_name || 'Student'}, your payment of ${cedis(total)} has been approved. Thank you.`;
            await sendViaArkesel([formatted], sms, { student_id: group[0].student_id });
            document.getElementById('approvalMessage').textContent = sms;
          }
        } catch (smsErr) { console.warn('Could not send approval SMS for grouped approval', smsErr); }
      }

      if (failed.length) {
        console.warn('Some grouped approvals failed:', failed);
        showModalMessage(`Approved ${approvedCount} item(s). ${failed.length} failed. See console for details.`);
      } else {
        showModalMessage(`Approved ${approvedCount} payment item(s) and notified the student.`);
      }
    }

    // Upsert a normalized payment row into the canonical `payments` table so admins and students
    // who read from `payments` see a central record. If the table doesn't exist, this will be
    // skipped silently to avoid noisy errors.
    async function upsertCanonicalPayment(payment, status) {
      if (!payment) return null;
      try {
        const payload = {
          student_id: payment.student_id || payment.studentId || payment.admission_number || payment.student_id,
          student_name: payment.student_name || payment.student_name || payment.name || '',
          student_email: payment.student_email || payment.email || '',
          department: payment.department || '',
          level: payment.level || '',
          amount: payment.amount_paid || payment.amount || 0,
          fee_type: payment.fee_type || payment.payment_type || '',
          // propagate coverage info when available (e.g., 'full', 'partial_80', 'partial_50')
          payment_coverage: payment.payment_coverage || payment.coverage || payment.paymentCoverage || null,
          coverage_percent: payment.coverage_percent || payment.coveragePercent || payment.coverage || null,
          transaction_ref: payment.transaction_ref || payment.payment_id || payment.payment_ref || null,
          payment_id: payment.payment_id || payment.id || null,
          receipt_number: payment.receipt_number || null,
          payment_date: payment.payment_date || payment.created_at || new Date().toISOString(),
          status: status || payment.status || 'approved',
          source_table: payment.source_table || payment.source_table || null,
          created_at: payment.created_at || new Date().toISOString()
        };

        // Try to find an existing row by payment_id or transaction_ref
        let matchQuery = null;
        if (payload.payment_id) matchQuery = sb.from('payments').select('*').eq('payment_id', payload.payment_id).limit(1);
        else if (payload.transaction_ref) matchQuery = sb.from('payments').select('*').eq('transaction_ref', payload.transaction_ref).limit(1);

        if (matchQuery) {
          try {
            const { data: existing, error: findErr } = await matchQuery;
            if (!findErr && existing && existing.length) {
              // Update existing
              const { data: u, error: upErr } = await sb.from('payments').update(payload).eq('id', existing[0].id).select();
              if (upErr) throw upErr;
              return u;
            }
          } catch (e) {
            // swallow find errors that indicate missing table
            const msg = e?.message || String(e);
            if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
              return null;
            }
            throw e;
          }
        }

        // Insert new canonical payment
        const { data, error } = await sb.from('payments').insert([payload]).select();
        if (error) {
          const msg = error.message || String(error);
          if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
            // payments table missing — skip silently
            return null;
          }
          throw error;
        }
        return data;
      } catch (err) {
        // Re-throw to caller or let caller handle the warning
        throw err;
      }
    }

    // Normalize phone number to international format (best-effort)
    function normalizePhone(phone){
      if(!phone) return null;
      let d = String(phone).replace(/\D/g,'');
      if(d.length === 9 && d.charAt(0) !== '0') return d; // maybe already Ghana without leading zero
      if (d.charAt(0) === '0') d = '233' + d.slice(1);
      if (d.length < 9) return null;
      return d;
    }

    // Generate PDF receipt using jsPDF
    function generatePdfReceipt(payment) {
      try {
        const studentName = (payment.student_name || (payment.student_record && (payment.student_record.full_name || payment.student_record.name)) || 'Student');
        const studentId = (payment.student_id || payment.admission_number || 'N/A');
        const feeType = (payment.fee_type || payment.payment_type || 'Fee');
        const amount = cedis(payment.amount_paid || payment.amount || 0);
        const receiptNo = (payment.receipt_number || payment.transaction_ref || payment.payment_id || 'N/A');
        const paymentMethod = (payment.payment_method || 'manual');
        const date = (formatDateTime(payment.payment_date || payment.created_at || new Date().toISOString()));

        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) {
          showModalMessage('PDF library not loaded. Please ensure jsPDF is available.');
          return;
        }

        const doc = new jsPDF({ unit: 'pt', format: 'a4' });
        const left = 40;
        let y = 40;
        doc.setFontSize(14);
        doc.setTextColor('#1e3a8a');
        doc.text('GH TECHNICAL UNIVERSITY — Finance Office', left, y);
        y += 20;
        doc.setFontSize(10);
        doc.setTextColor('#444');
        doc.text(`Official Payment Receipt`, left, y);
        y += 24;

        doc.setDrawColor('#ddd');
        doc.setLineWidth(0.5);
        doc.line(left, y, 555, y);
        y += 16;

        doc.setFontSize(9);
        doc.text(`Receipt: ${receiptNo}`, left, y);
        doc.text(`Date: ${date}`, 360, y);
        y += 18;

        doc.text(`Student: ${studentName}`, left, y);
        y += 14;
        doc.text(`Student ID: ${studentId}`, left, y);
        y += 14;
        doc.text(`Payment For: ${feeType}`, left, y);
        y += 14;
        doc.text(`Payment Method: ${paymentMethod}`, left, y);
        y += 18;

        doc.setFontSize(12);
        doc.setTextColor('#0b6b3a');
        doc.text(`Amount Paid: ${amount}`, left, y);
        y += 28;

        doc.setFontSize(9);
        doc.setTextColor('#444');
        doc.text(`Notes: ${payment.notes || ''}`, left, y);

        // Save PDF
        const filename = `receipt-${receiptNo}.pdf`;
        doc.save(filename);
      } catch (e) {
        console.error('generatePdfReceipt error', e);
        showModalMessage('Could not generate PDF receipt. See console for details.');
      }
    }

    // Generate a combined PDF receipt for multiple payments (same student / same base receipt)
    function generatePdfReceiptCombined(payments) {
      try {
        if (!Array.isArray(payments) || payments.length === 0) return;
        const first = payments[0];
        const studentName = (first.student_name || (first.student_record && (first.student_record.full_name || first.student_record.name)) || 'Student');
        const studentId = (first.student_id || first.admission_number || 'N/A');
        const date = formatDateTime(new Date().toISOString());

        // Compute totals and rows
        const rows = payments.map(p => {
          const feeKey = (p.fee_type || '').toString();
          // expected amount for known fees
          let expected = 0;
          const fk = (feeKey || '').toLowerCase();
          if (fk.includes('admission')) expected = ADMISSION_FEE;
          else if (fk.includes('tuition')) expected = TUITION_80;
          else if (fk.includes('src')) expected = SRC_DUES;
          else if (fk.includes('department')) expected = DEPT_DUES;
          else if (fk.includes('medical')) expected = MED_DUES;
          const paid = Number(p.amount_paid || p.amount || 0);
          const outstanding = expected > 0 ? Math.max(0, Math.round((expected - paid) * 100) / 100) : 0;
          return { fee: feeKey, expected, paid, outstanding, ref: p.receipt_number || p.transaction_ref || p.payment_id || '' };
        });

        const totalPaid = rows.reduce((s,r) => s + (r.paid||0), 0);
        const totalExpected = rows.reduce((s,r) => s + (r.expected||0), 0);
        const totalOutstanding = rows.reduce((s,r) => s + (r.outstanding||0), 0);

        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) { showModalMessage('PDF library not loaded. Please ensure jsPDF is available.'); return; }

        const doc = new jsPDF({ unit: 'pt', format: 'a4' });
        const w = doc.internal.pageSize.getWidth();
        const left = 40;
        let y = 40;

        // Blue header
        doc.setFillColor(14, 60, 130); // deep blue
        doc.rect(0, 0, w, 72, 'F');
        doc.setFontSize(18);
        doc.setTextColor('#ffffff');
        doc.text('GH TECHNICAL UNIVERSITY', left, 36);
        doc.setFontSize(10);
        doc.text('Finance Office — Official Receipt', left, 54);

        y = 92;

        // Student block
        doc.setFillColor(245, 248, 255); // very light blue
        doc.rect(left, y, w - left*2, 56, 'F');
        doc.setTextColor('#0b3a8a');
        doc.setFontSize(11);
        doc.text(`Student: ${studentName}`, left + 8, y + 18);
        doc.text(`Student ID: ${studentId}`, left + 8, y + 34);
        doc.text(`Date: ${date}`, w - 160, y + 18);
        y += 76;

        // Table header
        doc.setFillColor(230, 240, 255);
        doc.rect(left, y, w - left*2, 22, 'F');
        doc.setTextColor('#083066');
        doc.setFontSize(10);
        const colX = [left + 8, left + 200, left + 330, left + 430];
        doc.text('Fee Type', colX[0], y + 15);
        doc.text('Expected (GHS)', colX[1], y + 15);
        doc.text('Paid (GHS)', colX[2], y + 15);
        doc.text('Outstanding (GHS)', colX[3], y + 15);
        y += 28;

        // Rows
        doc.setFontSize(10);
        doc.setTextColor('#222');
        rows.forEach(r => {
          if (y > 720) { doc.addPage(); y = 40; }
          doc.text(escapeHtml(String(r.fee)), colX[0], y + 12);
          doc.text(String(r.expected ? cedis(r.expected) : 'N/A'), colX[1], y + 12);
          doc.text(String(cedis(r.paid)), colX[2], y + 12);
          doc.text(String(r.expected ? cedis(r.outstanding) : 'N/A'), colX[3], y + 12);
          y += 20;
        });

        y += 18;
        doc.setDrawColor('#cbd5e1');
        doc.setLineWidth(0.5);
        doc.line(left, y, w - left, y);
        y += 14;

        doc.setFontSize(11);
        doc.setTextColor('#083066');
        doc.text(`Total Paid: ${cedis(totalPaid)}`, left + 8, y);
        doc.text(`Total Expected: ${totalExpected ? cedis(totalExpected) : 'N/A'}`, left + 200, y);
        doc.text(`Total Outstanding: ${totalOutstanding ? cedis(totalOutstanding) : '0.00'}`, left + 380, y);
        y += 28;

        doc.setFontSize(9);
        doc.setTextColor('#444');
        doc.text('This receipt shows the individual payment items recorded and any outstanding balance per fee where an expected amount is defined. Keep this receipt for your records.', left + 8, y);

        // Footer
        doc.setFontSize(9);
        doc.setTextColor('#666');
        doc.text(`Generated by Finance Admin — ${formatDateTime(new Date().toISOString())}`, left, 810);

        const baseReceipt = first.receipt_number ? String(first.receipt_number).split('-')[0] : (first.transaction_ref || first.payment_id || Date.now());
        const filename = `receipt-${baseReceipt}.pdf`;
        doc.save(filename);
      } catch (e) {
        console.error('generatePdfReceiptCombined error', e);
        showModalMessage('Could not generate combined PDF receipt. See console for details.');
      }
    }

    function generatePdfReceiptById(paymentId){
      if(!paymentId) return;
      const payment = (allPayments || []).find(p => String(p.id) === String(paymentId) || String(p.payment_id) === String(paymentId) || String(p.transaction_ref) === String(paymentId));
      if(!payment){ showModalMessage('Payment not found for PDF generation'); return; }
      generatePdfReceipt(payment);
    }

    // Backwards-compatible wrappers
    function generateReceipt(payment){ generatePdfReceipt(payment); }
    function generateReceiptById(paymentId){ generatePdfReceiptById(paymentId); }

    // Update the student's record in the `students` table to add a notification
    // Update the student's record in the `students` table to add a notification.
    // If `opts.modalOnly` is true, we will only write the `notifications` history row
    // and skip updating the `students` quick-notification fields (so the dashboard banner
    // isn't used for these messages). `opts.meta` may contain an object stored with the note.
    async function setStudentNotification(studentId, message, opts = {}) {
      if (!studentId) return null;
      const modalOnly = opts && opts.modalOnly === true;
      const metaObj = opts && opts.meta ? opts.meta : { source: 'admin' };

      try {
        let data = null;

        if (!modalOnly) {
          const payload = {
            last_notification: message || '',
            notification_unread: true,
            last_notification_at: new Date().toISOString()
          };

          const res = await sb.from('students').update(payload).eq('student_id', studentId).select();
          if (res && res.error) {
            const msg = res.error.message || String(res.error);
            if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
              // table missing — continue to try writing history only
            } else {
              throw res.error;
            }
          } else {
            data = res && res.data ? res.data : data;
          }
        }

        // Best-effort: append a row to `notifications` so students have a history they can view.
        // If the table doesn't exist, we ignore the error to preserve compatibility.
        try {
          const note = {
            student_id: studentId,
            message: message || '',
            type: 'admin_message',
            meta: JSON.stringify(metaObj || { source: 'admin' }),
            read: false,
            created_at: new Date().toISOString()
          };
          await sb.from('notifications').insert([note]);
        } catch (noteErr) {
          const nmsg = noteErr?.message || String(noteErr || '');
          if (nmsg && !nmsg.toLowerCase().includes('not found')) console.warn('Could not write notifications row:', noteErr);
        }

        return data;
      } catch (err) {
        throw err;
      }
    }

    async function rejectPayment() {
      if (!currentPaymentId) return;
      
      const adminNotes = document.getElementById('adminNotes').value;
      
      // Update payment status in Supabase
      const success = await updatePaymentStatus(currentPaymentId, 'rejected', adminNotes);
      
      if (success) {
        showModalMessage(`Payment rejected!`);
        
        closeModal('paymentDetailModal');
        
        // Refresh data
        allPayments = await fetchAllPayments();
        loadPaymentReviewData();
        loadDashboardData();
      } else {
        showModalMessage('Error rejecting payment. Please try again.');
      }
    }

    async function revokePayment(paymentId) {
      if (!(await showConfirm('Are you sure you want to revoke this payment approval? The student will be notified.', 'Revoke Approval'))) return;
      // Update payment status in Supabase
      const success = await updatePaymentStatus(paymentId, 'pending', 'Payment approval revoked');

      if (success) {
        showModalMessage(`Payment approval revoked!`);

        // Refresh data
        allPayments = await fetchAllPayments();
        loadPaymentReviewData();
        loadDashboardData();
      } else {
        showModalMessage('Error revoking payment approval. Please try again.');
      }
    }

    /* -------------- STUDENT MANAGEMENT -------------- */
    function viewStudentDetails(studentId) {
      currentStudentId = studentId;
      
      // Find student in the fetched data
      const student = allStudents.find(s => {
        const candidates = [s.student_id, s.admission_number, s.id, s.studentId, s.admissionNumber, s.email];
        return candidates.some(c => String(c || '') === String(studentId));
      });
      
      if (!student) {
        showModalMessage('Student not found');
        return;
      }

      // Check student eligibility
      const eligibility = checkStudentEligibility(studentId);

      // Update student details
      const studentName = getFullName(student) || 'Unknown Student';
      
      document.getElementById('detailedStudentInfo').innerHTML = `
        <div class="student-detail-item">
          <div class="student-detail-label">Student ID</div>
          <div class="student-detail-value">${student.student_id || student.admission_number || student.id || studentId}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Student Name</div>
          <div class="student-detail-value">${studentName}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Email</div>
          <div class="student-detail-value">${student.email || student.contact_email || 'N/A'}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Phone</div>
          <div class="student-detail-value">${student.phone || student.phone_number || student.mobile || 'N/A'}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Program</div>
          <div class="student-detail-value">${student.program || student.program_applying_for || 'Not assigned'}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Department</div>
          <div class="student-detail-value">${student.department || 'Not assigned'}</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Level</div>
          <div class="student-detail-value">Level 100</div>
        </div>
        <div class="student-detail-item">
          <div class="student-detail-label">Admission Date</div>
          <div class="student-detail-value">${formatDate(student.created_at || student.createdAt || '')}</div>
        </div>
      `;

      // Update payment summary
      const elig = checkStudentEligibility(studentId);
      document.getElementById('studentPaymentSummary').innerHTML = `
        <div class="payment-info-item">
          <div class="payment-info-label">Admission Fee</div>
          <div class="payment-info-value">
            <span class="status-badge ${eligibility.admissionPaid ? 'status-paid' : 'status-unpaid'}">
              ${eligibility.admissionPaid ? 'Paid - GHS 800.00' : 'Unpaid - GHS 800.00 due'}
            </span>
          </div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Tuition (80%)</div>
          <div class="payment-info-value">
            <span class="status-badge ${eligibility.tuitionPaid ? 'status-paid' : 'status-unpaid'}">
              ${eligibility.tuitionPaid ? 'Paid - GHS 2,040.00' : 'Unpaid - GHS 2,040.00 due'}
            </span>
          </div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">SRC Dues</div>
          <div class="payment-info-value">
            <span class="status-badge ${eligibility.srcPaid ? 'status-paid' : 'status-unpaid'}">
              ${eligibility.srcPaid ? 'Paid - GHS 50.00' : 'Unpaid - GHS 50.00 due'}
            </span>
          </div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Departmental Dues</div>
          <div class="payment-info-value">
            <span class="status-badge ${eligibility.deptPaid ? 'status-paid' : 'status-unpaid'}">
              ${eligibility.deptPaid ? 'Paid - GHS 50.00' : 'Unpaid - GHS 50.00 due'}
            </span>
          </div>
        </div>
        <div class="payment-info-item">
          <div class="payment-info-label">Medical Dues</div>
          <div class="payment-info-value">
            <span class="status-badge ${eligibility.medPaid ? 'status-paid' : 'status-unpaid'}">
              ${elig.medPaid ? 'Paid - GHS 80.00' : 'Unpaid - GHS 80.00 due'}
            </span>
          </div>
        </div>
      `;

      // Render full payment list for this student
      try{
        const paymentsContainer = document.getElementById('studentPaymentsList');
        if (paymentsContainer) {
          const key = String(student.student_id || student.admission_number || student.id || studentId);
          const payments = allPayments.filter(p => {
            const candidates = [p.student_id, p.admission_number, p.studentId, p.admissionNumber, p.id, p.email, p.customer_email];
            return candidates.some(c => String(c || '') === key);
          }).sort((a,b)=> new Date(b.created_at||b.payment_date||0) - new Date(a.created_at||a.payment_date||0));

          if (!payments || payments.length === 0) {
            paymentsContainer.innerHTML = '<div style="color:var(--gray);">No payments recorded for this student.</div>';
          } else {
            let ph = `<div class="table-responsive"><table class="table"><thead><tr><th>Date</th><th>Type</th><th>Amount</th><th>Coverage</th><th>Status</th><th>Ref</th></tr></thead><tbody>`;
            payments.forEach(p => {
              const status = (p.status || 'pending');
              const coverageLabel = p.payment_coverage || (p.coverage_percent ? (p.coverage_percent >= 100 ? 'full' : p.coverage_percent + '%') : 'n/a');
              ph += `<tr><td>${formatDate(p.created_at||p.payment_date||'')}</td><td>${escapeHtml(p.fee_type||p.description||'Other')}</td><td>${cedis(p.amount_paid||p.amount||0)}</td><td>${escapeHtml(String(coverageLabel))}</td><td><span class="status-badge">${escapeHtml(status)}</span></td><td>${escapeHtml(p.transaction_ref||p.receipt_number||p.id||'')}</td></tr>`;
            });
            ph += `</tbody></table></div>`;
            paymentsContainer.innerHTML = ph;
          }
        }
      }catch(e){ console.warn('Could not render payments list', e); }

      // Update registration eligibility status
      const eligibilityStatus = document.getElementById('registrationEligibilityStatus');
      if (eligibility.allFeesPaid) {
        eligibilityStatus.innerHTML = `
          <div class="eligibility-status eligibility-approved">
            <i class="fas fa-check-circle"></i> 
            STUDENT ELIGIBLE FOR COURSE REGISTRATION
          </div>
        `;
      } else {
        eligibilityStatus.innerHTML = `
          <div class="eligibility-status eligibility-pending">
            <i class="fas fa-clock"></i> 
            STUDENT NOT ELIGIBLE - PENDING FEE PAYMENTS
          </div>
        `;
      }

      // Set registration status based on payment completion
      document.getElementById('registrationStatus').value = eligibility.allFeesPaid ? 'approved' : 'pending';

      openModal('studentDetailModal');
    }

    // Populate level/department/program filter options for students tab
    function populateStudentFilters() {
      try {
        const levelEl = document.getElementById('studentLevelFilter');
        const deptEl = document.getElementById('studentDepartmentFilter');
        const progEl = document.getElementById('studentProgramFilter');
        if (!levelEl && !deptEl && !progEl) return;

        const levels = new Set();
        const depts = new Set();
        const progs = new Set();

        (allStudents || []).forEach(s => {
          const lv = (s.level || s.level_name || s.levelName || '').toString().trim();
          const dp = (s.department || s.dept || s.department_name || '').toString().trim();
          const pg = (s.program || s.program_applying_for || s.program_name || '').toString().trim();
          if (lv) levels.add(lv);
          if (dp) depts.add(dp);
          if (pg) progs.add(pg);
        });

        if (levelEl) {
          const opts = ['<option value="">All Levels</option>'].concat(Array.from(levels).sort().map(l => `<option value="${escapeHtml(l)}">${escapeHtml(l)}</option>`)).join('');
          levelEl.innerHTML = opts;
        }

        if (deptEl) {
          const opts = ['<option value="">All Departments</option>'].concat(Array.from(depts).sort().map(d => `<option value="${escapeHtml(d)}">${escapeHtml(d)}</option>`)).join('');
          deptEl.innerHTML = opts;
        }

        if (progEl) {
          const opts = ['<option value="">All Programs</option>'].concat(Array.from(progs).sort().map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`)).join('');
          progEl.innerHTML = opts;
        }
      } catch (e) { console.warn('populateStudentFilters error', e); }
    }

    /**
     * Admin helper: search student by id/admission number and show full details + payments
     */
    async function adminSearchStudentById() {
      try {
        const input = document.getElementById('studentAccountSearchId');
        if (!input) { showModalMessage('Search input not found'); return; }
        const q = (input.value || '').trim();
        if (!q) { showModalMessage('Please enter a Student ID or Admission Number'); return; }

        // Ensure caches are populated
        allStudents = await fetchAllStudents();
        allPayments = await fetchAllPayments();

        // Try to find in cache first
        let student = allStudents.find(s => (s.student_id && String(s.student_id) === q) || (s.admission_number && String(s.admission_number) === q) || (s.id && String(s.id) === q));

        if (!student) {
          // Query likely student tables directly with OR
          const candidateTables = ['students', 'newstudents'];
          for (const table of candidateTables) {
            try {
              const { data, error } = await sb.from(table)
                .select('*')
                .or(`student_id.eq.${q},admission_number.eq.${q},email.eq.${q}`)
                .limit(1);

              if (!error && data && data.length) {
                student = data[0];
                student.source_table = table;
                break;
              }
            } catch (e) {
              // ignore table-not-found style errors
              const msg = e?.message || String(e);
              if (msg && (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404'))) continue;
              console.warn('Error querying', table, e);
            }
          }
        }

        if (!student) {
          showModalMessage('Student not found');
          return;
        }

        // Ensure the student is available in the cache used by viewStudentDetails
        const key = student.student_id || student.admission_number || student.id;
        if (!allStudents.some(s => (s.student_id || s.admission_number || s.id) == key)) {
          allStudents.unshift(student);
        }

        // Refresh payments cache so payment summary shows up-to-date info
        allPayments = await fetchAllPayments();

        // Use existing viewStudentDetails which will render details and open modal
        viewStudentDetails(key);
      } catch (err) {
        console.error('Error searching student:', err);
        showModalMessage('Error searching student. See console for details.');
      }
    }

    function updateStudentStatus() {
      if (!currentStudentId) return;

      const registrationStatus = document.getElementById('registrationStatus').value;
      const adminNotes = document.getElementById('adminStudentNotes').value;

      // In a real implementation, we would update the student's registration status in Supabase
      showModalMessage(`Student ${currentStudentId} registration status updated to: ${registrationStatus}`);

      closeModal('studentDetailModal');
      loadStudents();
      loadDashboardData();
    }

    /* -------------- REPORTS -------------- */
    function loadReports() {
      // Show/hide custom date range based on selection
      document.getElementById('reportPeriod').addEventListener('change', function() {
        const customDateRange = document.getElementById('customDateRange');
        if (this.value === 'custom') {
          customDateRange.style.display = 'block';
        } else {
          customDateRange.style.display = 'none';
        }
      });

      // Generate report preview with real data
      const approvedPayments = allPayments.filter(p => p.status === 'approved');
      const pendingPayments = allPayments.filter(p => p.status === 'pending');
      const rejectedPayments = allPayments.filter(p => p.status === 'rejected');

      // Calculate payment summary by fee type
      const feeTypeSummary = {};
      approvedPayments.forEach(payment => {
        const feeType = payment.fee_type || 'Other';
        if (!feeTypeSummary[feeType]) {
          feeTypeSummary[feeType] = {
            count: 0,
            amount: 0
          };
        }
        feeTypeSummary[feeType].count++;
        feeTypeSummary[feeType].amount += payment.amount_paid || 0;
      });

      let reportHtml = '';
      Object.entries(feeTypeSummary).forEach(([feeType, data]) => {
        reportHtml += `
          <tr>
            <td>${feeType}</td>
            <td>${data.count}</td>
            <td>${cedis(data.amount)}</td>
            <td>${data.count}</td>
            <td>${pendingPayments.filter(p => p.fee_type === feeType).length}</td>
            <td>${rejectedPayments.filter(p => p.fee_type === feeType).length}</td>
          </tr>
        `;
      });

      // Calculate totals
      const totalCount = approvedPayments.length + pendingPayments.length + rejectedPayments.length;
      const totalAmount = approvedPayments.reduce((sum, p) => sum + (p.amount_paid || 0), 0);

      document.getElementById('reportPreview').innerHTML = `
        <div class="card">
          <div class="card-header">
            <h3>Payment Summary Report - This Month</h3>
          </div>
          <div class="card-body">
            <div class="table-responsive">
              <table class="table">
                <thead>
                  <tr>
                    <th>Payment Type</th>
                    <th>Number of Payments</th>
                    <th>Total Amount</th>
                    <th>Approved</th>
                    <th>Pending</th>
                    <th>Rejected</th>
                  </tr>
                </thead>
                <tbody>
                  ${reportHtml}
                  <tr style="font-weight: bold; background: var(--light);">
                    <td>Total</td>
                    <td>${totalCount}</td>
                    <td>${cedis(totalAmount)}</td>
                    <td>${approvedPayments.length}</td>
                    <td>${pendingPayments.length}</td>
                    <td>${rejectedPayments.length}</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      `;
    }

    function generateReport() {
      const reportType = document.getElementById('reportType').value;
      const reportPeriod = document.getElementById('reportPeriod').value;
      const reportFormat = document.getElementById('reportFormat').value;

      showModalMessage(`Generating ${reportType} report for ${reportPeriod} in ${reportFormat.toUpperCase()} format...`);
    }

    function exportReportData() {
      showModalMessage('Exporting report data...');
    }

    // Export payments only as CSV
    async function exportPaymentData() {
      try {
        showModalMessage('Preparing payments CSV...');
        const payments = await fetchAllPayments();
        if (!payments || !payments.length) return showModalMessage('No payments to export');

        const headers = ['payment_id','transaction_ref','receipt_number','source_table','status','payment_date','amount','fee_type','payment_method','student_id','student_name','student_email','phone','level','department','program'];
        function esc(v){ if (v === null || v === undefined) return ''; const s = String(v); if (s.indexOf(',')!==-1||s.indexOf('"')!==-1||s.indexOf('\n')!==-1) return '"'+s.replace(/"/g,'""')+'"'; return s; }
        let csv = headers.join(',') + '\n';
        payments.forEach(p => {
          const s = p.student_record || {};
          const row = [p.payment_id||p.id||'', p.transaction_ref||'', p.receipt_number||'', p.source_table||'', p.status||'', p.payment_date||p.created_at||'', p.amount_paid||p.amount||0, p.fee_type||p.payment_type||'', p.payment_method||'', s.student_id||s.admission_number||p.student_id||'', s.full_name||s.name||p.student_name||'', s.email||p.student_email||'', s.phone||s.phone_number||p.phone||p.student_phone||'', p.level||s.level||'', p.department||s.department||'', p.program||s.program||''];
          csv += row.map(esc).join(',') + '\n';
        });

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `payments_export_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        showModalMessage('Payments CSV download started');
      } catch (e) { console.error('exportPaymentData', e); showModalMessage('Could not export payments'); }
    }

    // Export students only as CSV
    async function exportStudentData() {
      try {
        showModalMessage('Preparing students CSV...');
        const students = await fetchAllStudents();
        if (!students || !students.length) return showModalMessage('No students to export');

        const headers = ['student_id','admission_number','full_name','email','phone','phone_number','level','department','program','created_at'];
        function esc(v){ if (v === null || v === undefined) return ''; const s = String(v); if (s.indexOf(',')!==-1||s.indexOf('"')!==-1||s.indexOf('\n')!==-1) return '"'+s.replace(/"/g,'""')+'"'; return s; }
        let csv = headers.join(',') + '\n';
        students.forEach(s => {
          const row = [s.student_id||s.id||'', s.admission_number||'', s.full_name||s.name||s.first_name||'', s.email||'', s.phone||'', s.phone_number||'', s.level||'', s.department||s.program||'', s.created_at||''];
          csv += row.map(esc).join(',') + '\n';
        });

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `students_export_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        showModalMessage('Students CSV download started');
      } catch (e) { console.error('exportStudentData', e); showModalMessage('Could not export students'); }
    }

    /* -------------- LEGACY NOTIFICATIONS (delegated) -------------- */
    function loadSmsDataLegacy() {
      // Legacy compatibility: delegate to SMS implementation
      console.warn('legacy loadSmsData called; delegating to loadSmsData()');
      return loadSmsData();
    }

    function updateCharCount() {
      // Prefer SMS message field
      const msgEl = document.getElementById('smsMessage');
      const message = (msgEl && msgEl.value) || '';
      const charCount = message.length;
      const charCountEl = document.getElementById('charCount');
      if (charCountEl) charCountEl.textContent = charCount;
      // Update preview
      const previewEl = document.getElementById('previewMessage');
      if (previewEl) previewEl.textContent = message || 'Your message will appear here...';
    }

    function previewSmsLegacy() { previewSms(); }
    function confirmSendSmsLegacy() { confirmSendSms(); }
    function sendSmsLegacy() { sendSms(); }

    function sendApprovalSms() {
      (async function(){
        if (!currentApprovedPayment) return;

        // Try to find the student locally first
        let student = allStudents.find(s => 
          s.student_id === currentApprovedPayment.student_id || 
          s.admission_number === currentApprovedPayment.student_id
        );

        // If not found or phone missing, try to fetch from Supabase directly
        try {
          if (!student || !(student.phone || student.phone_number)) {
            const id = currentApprovedPayment.student_id;
            if (id) {
              const { data, error } = await sb.from('students').select('student_id,admission_number,phone,phone_number').or(`student_id.eq.${id},admission_number.eq.${id}`).limit(1).maybeSingle();
              if (!error && data) student = Object.assign({}, student || {}, data);
            }
          }
        } catch (err) {
          console.warn('Could not fetch student phone from Supabase:', err?.message || err);
        }

        const rawPhone = student?.phone || student?.phone_number;

        function normalizeForSms(phone) {
          if (!phone) return null;
          // Strip non-digits
          let digits = String(phone).replace(/\D/g, '');
          // If number starts with 0, assume Ghana local and replace leading 0 with 233
          if (digits.length > 0 && digits.charAt(0) === '0') {
            digits = '233' + digits.slice(1);
          }
          if (digits.length < 9) return null;
          return digits;
        }

        const formattedPhone = normalizeForSms(rawPhone);

        if (!formattedPhone) {
          showModalMessage('Student phone number not found or invalid. Please confirm the student phone in the student record.');
          closeModal('paymentApprovalModal');
          return;
        }

        const message = document.getElementById('approvalMessage').textContent || '';
        const encodedMessage = encodeURIComponent(message);
        const smsUrl = `sms:${formattedPhone}?body=${encodedMessage}`;

        // Try to record a small history row (non-blocking) so admin can see that an intent was created
        (async function recordHistory(){
          try {
            const payload = {
              student_id: currentApprovedPayment.student_id,
              phone: formattedPhone,
              message: message,
              sent_at: new Date().toISOString(),
              status: 'intent_opened'
            };
            const { data, error } = await sb.from('sms_messages').insert([payload]).select();
            if (error) {
              // Table may not exist — ignore silently
            }
          } catch (e) {
            // ignore
          }
        })();

        // Open SMS composer (mobile browsers will handle this). On desktop this may be a no-op.
        window.open(smsUrl, '_blank');
        showModalMessage('SMS composer opened (or intent recorded) with the approval message.');

        closeModal('paymentApprovalModal');
      })();
    }

    function loadSmsHistoryLegacy() {
      // Legacy compatibility: use SMS history loader
      console.warn('loadSmsHistoryLegacy() is deprecated; delegating to loadSmsHistory()');
      return loadSmsHistory();
    }

    /* -------------- SMS NOTIFICATIONS (new) -------------- */
    function loadSmsData() {
      if (!document.getElementById('smsRecipient')) return;

      // Show/hide specific student selection
      document.getElementById('smsRecipient').addEventListener('change', function() {
        const specificStudent = document.getElementById('specificStudent');
        if (this.value === 'specific') {
          specificStudent.style.display = 'block';

          // Populate student dropdown
          let options = '<option value="">Select a student</option>';
          allStudents.forEach(student => {
            const studentName = escapeHtml(getFullName(student) || 'Unknown Student');
            const studentId = escapeHtml(student.student_id || student.admission_number || 'N/A');
            options += `<option value="${studentId}">${studentName} (${studentId})</option>`;
          });
          const sel = document.getElementById('studentSelect');
          if (sel) sel.innerHTML = options;
          // Attach change handler to auto-fill the recipient phones box when a student is selected
          if (sel) {
            sel.addEventListener('change', function() {
              try {
                const sid = this.value;
                const student = allStudents.find(s => (s.student_id || s.admission_number || '').toString() === sid.toString());
                let phoneField = document.getElementById('smsRecipientPhones');
                if (!phoneField) {
                  // create a readonly input below the template selector for visibility
                  const anchor = document.getElementById('smsTemplate') || document.getElementById('smsMessage');
                  phoneField = document.createElement('input');
                  phoneField.id = 'smsRecipientPhones';
                  phoneField.readOnly = true;
                  phoneField.placeholder = 'Resolved recipient phone(s) will appear here';
                  phoneField.style.width = '100%';
                  phoneField.style.marginTop = '8px';
                  phoneField.style.padding = '8px';
                  phoneField.style.border = '1px solid #ddd';
                  phoneField.style.borderRadius = '6px';
                  if (anchor && anchor.parentNode) anchor.parentNode.insertBefore(phoneField, anchor.nextSibling);
                }
                if (!student) { phoneField.value = ''; return; }
                // normalize phone
                function norm(p){ if(!p) return null; let d=String(p).replace(/\D/g,''); if(d.charAt(0)==='0') d='233'+d.slice(1); return d.length<9?null:d; }
                const raw = student.phone || student.phone_number || student.mobile || '';
                const formatted = norm(raw);
                phoneField.value = formatted || '';
              } catch (e) { console.warn('Auto-fill student phone failed', e); }
            });
          }
        } else {
          specificStudent.style.display = 'none';
        }
      });

      // Create/maintain a recipient-phones preview when admin switches recipient group
      (function setupRecipientPreview(){
        const recipientEl = document.getElementById('smsRecipient');
        if (!recipientEl) return;
        let phoneField = document.getElementById('smsRecipientPhones');
        if (!phoneField) {
          const anchor = document.getElementById('smsTemplate') || document.getElementById('smsMessage');
          phoneField = document.createElement('input');
          phoneField.id = 'smsRecipientPhones';
          phoneField.readOnly = true;
          phoneField.placeholder = 'Resolved recipient phone(s) will appear here';
          phoneField.style.width = '100%'; phoneField.style.marginTop = '8px'; phoneField.style.padding = '8px'; phoneField.style.border = '1px solid #ddd'; phoneField.style.borderRadius = '6px';
          if (anchor && anchor.parentNode) anchor.parentNode.insertBefore(phoneField, anchor.nextSibling);
        }

        async function updatePreview(){
          try {
            const recipient = (recipientEl && recipientEl.value) || 'all';
            // helper
            function normalizeForSms(phone){ if(!phone) return null; let d=String(phone).replace(/\D/g,''); if(d.charAt(0)==='0') d='233'+d.slice(1); return d.length<9?null:d; }
            const list = [];
            if (recipient === 'specific') {
              const sel = document.getElementById('studentSelect'); const sid = sel && sel.value;
              if (sid) {
                const student = allStudents.find(s => (s.student_id || s.admission_number || '').toString() === sid.toString());
                if (student) { const p = normalizeForSms(student.phone || student.phone_number || student.mobile); if (p) list.push(p); }
              }
            } else if (recipient === 'all') {
              allStudents.forEach(s => { const p = normalizeForSms(s.phone || s.phone_number || s.mobile); if (p) list.push(p); });
            } else if (recipient === 'pending' || recipient === 'approved') {
              const ids = [...new Set(allPayments.filter(p => (p.status||'') === recipient).map(p => p.student_id))];
              ids.forEach(id => { const student = allStudents.find(s => (s.student_id||s.admission_number||'').toString() === (id||'').toString()); if (student) { const p = normalizeForSms(student.phone || student.phone_number || student.mobile); if(p) list.push(p); } });
            }
            const dedup = [...new Set(list)].slice(0,500);
            if (dedup.length > 20) {
              phoneField.value = `${dedup.length} recipients (preview truncated)`;
              phoneField.title = dedup.slice(0,50).join(',');
            } else {
              phoneField.value = dedup.join(', ');
              phoneField.title = '';
            }
          } catch (e) { console.warn('Could not update recipient preview', e); }
        }

        recipientEl.addEventListener('change', updatePreview);
        // Also update when studentSelect changes (specific)
        const studentSelectEl = document.getElementById('studentSelect'); if (studentSelectEl) studentSelectEl.addEventListener('change', updatePreview);
        // initial populate
        setTimeout(updatePreview, 80);
      })();

      // Update message based on template
      const templateSelect = document.getElementById('smsTemplate');
      const messageField = document.getElementById('smsMessage');
      if (templateSelect && messageField) {
        templateSelect.addEventListener('change', function() {
          const templates = {
            'payment-approved': 'GH TECHNICAL — Your payment has been approved. You can now proceed with course registration. Thank you.',
            'payment-received': '📝 We have received your payment. It is currently under review. You will be notified once approved. Thank you for choosing GH Technical University!',
            'registration-eligible': '✅ You are now eligible for course registration. Please log in to your student portal to register for courses. Thank you for choosing GH Technical University!',
            'payment-reminder': '🔔 This is a reminder that your payment is due. Please make payment to avoid registration delays. Thank you for choosing GH Technical University!',
            'custom': ''
          };
          messageField.value = templates[this.value] || '';
          updateSmsCharCount();
        });
        messageField.addEventListener('input', updateSmsCharCount);
      }

      // Load SMS history
      loadSmsHistory();
    }

    function updateSmsCharCount() {
      const msgEl = document.getElementById('smsMessage');
      if (!msgEl) return;
      const message = msgEl.value || '';
      const charCount = message.length;
      const charNode = document.getElementById('charCount');
      if (charNode) charNode.textContent = charCount;

      // Update preview area if present
      const previewEl = document.getElementById('previewMessage') || document.getElementById('previewModalMessage');
      if (previewEl) previewEl.textContent = message || 'Your message will appear here...';
    }

    function previewSms() {
      const recipient = (document.getElementById('smsRecipient') && document.getElementById('smsRecipient').value) || 'all';
      const message = (document.getElementById('smsMessage') && document.getElementById('smsMessage').value) || '';

      if (!message) {
        showModalMessage('Please enter a message');
        return;
      }

      // Update preview modal fields (reuse existing preview modal ids)
      const previewRecipientEl = document.getElementById('previewRecipient');
      const previewCountEl = document.getElementById('previewRecipientCount');
      const previewMessageEl = document.getElementById('previewModalMessage') || document.getElementById('previewMessage');

      if (previewRecipientEl) previewRecipientEl.textContent =
        recipient === 'all' ? 'All Students' :
        recipient === 'pending' ? 'Students with Pending Payments' :
        recipient === 'approved' ? 'Students with Approved Payments' :
        'Specific Student';

      // Count recipients
      let recipientCount = 0;
      switch(recipient) {
        case 'all': recipientCount = allStudents.length; break;
        case 'pending': recipientCount = [...new Set(allPayments.filter(p => p.status === 'pending').map(p => p.student_id))].length; break;
        case 'approved': recipientCount = [...new Set(allPayments.filter(p => p.status === 'approved').map(p => p.student_id))].length; break;
        case 'specific': recipientCount = 1; break;
      }

      if (previewCountEl) previewCountEl.textContent = `${recipientCount} students`;
      if (previewMessageEl) previewMessageEl.textContent = message;

      // Open preview modal (SMS)
      openModal('smsPreviewModal');
    }

    function confirmSendSms() {
      const recipient = (document.getElementById('smsRecipient') && document.getElementById('smsRecipient').value) || 'all';
      const template = (document.getElementById('smsTemplate') && document.getElementById('smsTemplate').value) || 'custom';
      const message = (document.getElementById('smsMessage') && document.getElementById('smsMessage').value) || '';

      if (!message) { showModalMessage('Please enter a message'); return; }

      (async function(){
        try {
          const payload = {
            recipient: recipient,
            template: template,
            message: message,
            created_at: new Date().toISOString(),
            status: 'intent_created'
          };

          try {
            const { data, error } = await sb.from('sms_messages').insert([payload]).select();
            if (error) {
              // Attempt a tolerant retry when schema differs (missing columns like `template`)
              const msg = (error.message || '').toString().toLowerCase();
              console.warn('Initial sms_messages insert error:', error.message || error);
              if (msg.includes('template') || msg.includes('column "template"') || msg.includes('does not exist')) {
                // Retry without `template` and `recipient` fields (use phone/message/status)
                try {
                  const safePayload = { message: message, created_at: new Date().toISOString(), status: 'intent_created' };
                  await sb.from('sms_messages').insert([safePayload]).select();
                  showModalMessage('SMS intent recorded (compatibility fallback). Messages will be delivered by your configured SMS gateway.');
                } catch (retryErr) {
                  console.warn('Fallback insert also failed:', retryErr);
                  showModalMessage('SMS intent recorded locally (table present but insert failed).');
                }
              } else {
                console.warn('Could not insert sms history:', error.message || error);
                showModalMessage('SMS intent recorded locally (table missing on server).');
              }
            } else {
              showModalMessage('SMS intent recorded. Messages will be delivered by your configured SMS gateway.');
            }
          } catch (e) {
            // Unexpected exception — don't block sending flow
            console.warn('Could not record SMS intent (exception):', e);
            showModalMessage('SMS intent recorded locally (error recording intent).');
          }
        } catch (e) {
          console.warn('Could not record SMS intent:', e);
        } finally {
          closeModal('smsPreviewModal');
          loadSmsHistory();

          // After recording intent, attempt to send via Arkesel immediately
          try {
            // Build recipient phone list
            const phones = await (async function buildPhones(){
              const list = [];
              // helper to normalize phone
              function normalizeForSms(phone){
                if (!phone) return null;
                let digits = String(phone).replace(/\D/g, '');
                if (digits.charAt(0) === '0') digits = '233' + digits.slice(1);
                if (digits.length < 9) return null;
                return digits;
              }

              if (recipient === 'specific') {
                const sel = document.getElementById('studentSelect');
                const sid = sel && sel.value;
                if (sid) {
                  const student = allStudents.find(s => (s.student_id || s.admission_number || '').toString() === sid.toString());
                  if (student) {
                    const p = normalizeForSms(student.phone || student.phone_number || student.mobile);
                    if (p) list.push(p);
                  }
                }
              } else {
                // gather from students/payments depending on recipient
                if (recipient === 'all') {
                  allStudents.forEach(s => { const p = normalizeForSms(s.phone || s.phone_number || s.mobile); if(p) list.push(p); });
                } else if (recipient === 'pending' || recipient === 'approved') {
                  const ids = [...new Set(allPayments.filter(p=> p.status === recipient).map(p => p.student_id))];
                  ids.forEach(id => {
                    const student = allStudents.find(s => (s.student_id || s.admission_number || '').toString() === (id||'').toString());
                    if (student) { const p = normalizeForSms(student.phone || student.phone_number || student.mobile); if(p) list.push(p); }
                  });
                }
              }

              // Deduplicate
              return [...new Set(list)].slice(0, 500); // limit to 500 recipients for safety
            })();

            if (!phones || phones.length === 0) {
              console.warn('No recipient phone numbers found for sending SMS.');
              return;
            }

            // Send via Arkesel helper
            await sendViaArkesel(phones, message, {recipient, template});
          } catch (sendErr) {
            console.warn('Error attempting to send SMS via gateway:', sendErr);
          }
        }
      })();
    }

    // Send messages using Arkesel (or a proxy if configured)
    async function sendViaArkesel(phoneNumbers, message, meta) {
      if (!phoneNumbers || phoneNumbers.length === 0) return;
      // send sequentially to avoid bursts; record detailed gateway responses
      for (let i = 0; i < phoneNumbers.length; i++) {
        const to = phoneNumbers[i];
        try {
          let resp = null;
          if (USE_PROXY && PROXY_ENDPOINT) {
            resp = await fetch(PROXY_ENDPOINT, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ to, message, meta })
            });
          } else {
            // Direct call to Arkesel - provider may expect form-encoded data or different field names.
            // Keep this as a fallback for testing, but prefer a server-side proxy to avoid CORS and expose keys.
            resp = await fetch(ARKESEL_API_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                email: ARKESEL_API_EMAIL,
                api_key: ARKESEL_API_KEY,
                sender_id: ARKESEL_SENDER_ID,
                to,
                message
              })
            });
          }

          // Attempt to parse response body intelligently
          let gatewayResponse = '';
          let success = false;
          try {
            const contentType = (resp && resp.headers && resp.headers.get && resp.headers.get('content-type')) || '';
            if (contentType.includes('application/json')) {
              const parsed = await resp.json();
              gatewayResponse = JSON.stringify(parsed);
              // Heuristics for success detection
              if (resp.ok) success = true;
              if (parsed && (parsed.status === 'success' || parsed.status === 'ok' || parsed.success === true || parsed.code === 0)) success = true;
            } else {
              // fallback to text
              try {
                gatewayResponse = await resp.text();
              } catch (e) { gatewayResponse = String(resp && resp.status || 'no response'); }
              if (resp && resp.ok) success = true;
            }
          } catch (parseErr) {
            gatewayResponse = `Could not parse gateway response: ${parseErr?.message || parseErr}`;
            success = !!(resp && resp.ok);
          }

          // Helpful warning when using direct calls from browser (likely to hit CORS or security issues)
          if (!USE_PROXY && resp && !resp.ok) {
            console.warn('Direct SMS gateway call failed. Consider deploying a server proxy and set PROXY_ENDPOINT to avoid CORS and hide API keys. Response:', resp.status, gatewayResponse);
          }

          // Record result in sms_messages table (best-effort)
          try {
            const payload = {
              student_id: (meta && meta.student_id) || null,
              phone: to,
              message: message,
              created_at: new Date().toISOString(),
              status: success ? 'sent' : 'failed',
              gateway_response: gatewayResponse
            };
            await sb.from('sms_messages').insert([payload]);
          } catch (recErr) {
            console.warn('Could not record SMS send result:', recErr);
          }

        } catch (e) {
          // More verbose error logging to help diagnose network / CORS / proxy issues
          console.warn('Failed sending SMS to', to, 'Error object:', e);
          try { console.warn('Error message:', e && e.message); } catch(_){}
          try { console.warn('Error stack:', e && e.stack); } catch(_){}

          // Provide a visible hint to the admin (non-blocking)
          try {
            const hint = `Failed to send SMS to ${to}. Check network, proxy (${PROXY_ENDPOINT}), and CORS. Error: ${String(e && (e.message || e))}`;
            console.warn(hint);
            // show modal for immediate feedback (do not spam)
            showModalMessage(hint, 'SMS Send Failed');
          } catch(_){}

          try {
            await sb.from('sms_messages').insert([{ phone: to, message: message, created_at: new Date().toISOString(), status: 'failed', gateway_response: String(e && (e.message || e) || 'failed to fetch') }]);
          } catch (_){ }
        }

        // small pause between requests
        await new Promise(res => setTimeout(res, 250));
      }

      // refresh history after sending
      loadSmsHistory();
    }

    function sendSms() {
      // For now, show preview modal before confirming
      previewSms();
    }

    async function loadSmsHistory() {
      const container = document.getElementById('smsHistory');
      if (!container) return;

      try {
        // Prefer ordering by `created_at`. If your `sms_messages` table defines `sent_at`, consider adding it.
        const { data, error } = await sb.from('sms_messages').select('*').order('created_at', { ascending: false }).limit(50);
        if (error) {
          const msg = error.message || String(error);
          if (msg.includes('Could not find the table') || msg.toLowerCase().includes('not found') || msg.includes('404')) {
            // Table missing — show sample rows
            container.innerHTML = `
              <div class="table-responsive">
                <table class="table">
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Recipient</th>
                      <th>Message</th>
                      <th>Status</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr><td>${formatDateTime(new Date())}</td><td>All Students</td><td>Welcome to GH Technical University! Registration...</td><td><span class="status-badge status-approved">Recorded</span></td></tr>
                  </tbody>
                </table>
              </div>
            `;
            return;
          }
          throw error;
        }

        if (!data || !data.length) {
          container.innerHTML = `<div style="color:var(--gray);">No SMS history found</div>`;
          document.getElementById('smsTotalCount').textContent = '0';
          document.getElementById('smsTotalSent').textContent = '0';
          return;
        }

        // compute totals
        const totalCount = data.length;
        const totalSent = data.filter(d => d.status === 'sent').length;
        try{ document.getElementById('smsTotalCount').textContent = totalCount; }catch(e){}
        try{ document.getElementById('smsTotalSent').textContent = totalSent; }catch(e){}

        let html = `
          <div class="table-responsive">
            <table class="table">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Recipient</th>
                  <th>Message</th>
                  <th>Status</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>`;

        data.forEach(row => {
          html += `
            <tr>
              <td>${formatDateTime(row.created_at || row.sent_at || new Date())}</td>
              <td>${escapeHtml(row.recipient || row.student_id || row.phone || 'N/A')}</td>
              <td>${escapeHtml((row.message || '').slice(0, 300))}</td>
              <td><span class="status-badge ${row.status === 'sent' ? 'status-approved' : 'status-pending'}">${escapeHtml(row.status || 'intent')}</span></td>
              <td>
                <button class="btn btn-sm" onclick="editSms('${row.id || ''}')"><i class="fas fa-edit"></i> Edit</button>
                <button class="btn btn-sm btn-danger" onclick="deleteSms('${row.id || ''}')"><i class="fas fa-trash"></i> Delete</button>
              </td>
            </tr>`;
        });

        html += `</tbody></table></div>`;
        container.innerHTML = html;
          } catch (err) {
            console.warn('Could not load sms history:', err);
            container.innerHTML = `<div style="color:var(--gray);">Could not load SMS history</div>`;
            showModalMessage('Error loading data. See console for details.');
          }
    }

    // SMS edit/delete/export helpers
    let __currentSmsEditId = null;
    async function editSms(id) {
      if (!id) return showModalMessage('No SMS id');
      try {
        const { data, error } = await sb.from('sms_messages').select('*').eq('id', id).limit(1).maybeSingle();
        if (error || !data) return showModalMessage('SMS record not found');
        __currentSmsEditId = id;
        document.getElementById('smsEditRecipient').value = data.recipient || data.student_id || data.phone || '';
        document.getElementById('smsEditMessage').value = data.message || '';
        document.getElementById('smsEditStatus').value = data.status || 'intent';
        openModal('smsEditModal');
      } catch (e) { console.error('editSms error', e); showModalMessage('Could not load SMS record'); }
    }

    async function saveSmsEdit() {
      if (!__currentSmsEditId) return showModalMessage('No SMS selected');
      try {
        const recipient = document.getElementById('smsEditRecipient').value;
        const message = document.getElementById('smsEditMessage').value;
        const status = document.getElementById('smsEditStatus').value;
        const payload = { recipient: recipient || null, phone: recipient || null, message: message, status: status };
        const { data, error } = await sb.from('sms_messages').update(payload).eq('id', __currentSmsEditId).select();
        if (error) throw error;
        closeModal('smsEditModal');
        showModalMessage('SMS updated');
        loadSmsHistory();
      } catch (e) { console.error('saveSmsEdit', e); showModalMessage('Could not update SMS'); }
    }

    async function deleteSms(id) {
      if (!id) return showModalMessage('No SMS id');
      if (!(await showConfirm('Delete this SMS record? This cannot be undone.', 'Confirm Delete'))) return;
      try {
        const { data, error } = await sb.from('sms_messages').delete().eq('id', id).select();
        if (error) throw error;
        showModalMessage('SMS deleted');
        loadSmsHistory();
      } catch (e) { console.error('deleteSms', e); showModalMessage('Could not delete SMS record'); }
    }

    async function exportSmsCsv() {
      try {
        const { data, error } = await sb.from('sms_messages').select('*').order('created_at', { ascending: false }).limit(1000);
        if (error) throw error;
        if (!data || !data.length) return showModalMessage('No SMS rows to export');
        const rows = data.map(r => ({ date: r.created_at, recipient: r.recipient || r.student_id || r.phone, message: r.message, status: r.status }));
        const csv = [Object.keys(rows[0]).join(',')].concat(rows.map(r => Object.values(r).map(v => '"' + String(v).replace(/"/g,'""') + '"').join(','))).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'sms_history.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      } catch (e) { console.error('exportSmsCsv', e); showModalMessage('Could not export CSV'); }
    }

    async function exportSmsPdf() {
      try {
        const { data, error } = await sb.from('sms_messages').select('*').order('created_at', { ascending: false }).limit(500);
        if (error) throw error;
        if (!data || !data.length) return showModalMessage('No SMS rows to export');
        let html = `<html><head><title>SMS History</title><style>table{width:100%;border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px;font-size:12px}</style></head><body><h3>SMS History</h3><table><thead><tr><th>Date</th><th>Recipient</th><th>Message</th><th>Status</th></tr></thead><tbody>`;
        data.forEach(r => { html += `<tr><td>${formatDateTime(r.created_at)}</td><td>${escapeHtml(r.recipient || r.student_id || r.phone || '')}</td><td>${escapeHtml((r.message||'').slice(0,500))}</td><td>${escapeHtml(r.status||'')}</td></tr>`; });
        html += `</tbody></table></body></html>`;
        const w = window.open('','_blank','width=900,height=700'); if(!w) return showModalMessage('Could not open print window');
        w.document.write(html); w.document.close(); w.focus(); // user can print to PDF
      } catch (e) { console.error('exportSmsPdf', e); showModalMessage('Could not export PDF'); }
    }

    /* ---------- Combined Fetch + Render for Payments and Students ---------- */
    async function fetchPaymentsAndStudents() {
      // Reuse existing fetch helpers which already probe likely tables
      const payments = await fetchAllPayments();
      const students = await fetchAllStudents();

      // Build a fast lookup map for students by common keys
      const studentMap = new Map();
      students.forEach(s => {
        const key = (s.student_id || s.admission_number || s.email || '').toString();
        if (key) studentMap.set(key, s);
      });

      // Enrich payments with student record when available
      const enriched = payments.map(p => {
        const key = (p.student_id || p.admission_number || p.email || '').toString();
        const student = studentMap.get(key) || null;
        return Object.assign({}, p, { student_record: student });
      });

      return { payments: enriched, students };
    }

    async function openAllDataModal(){
        try {
          const tbody = document.getElementById('allDataTbody');
          const modal = document.getElementById('allDataModal') || document.getElementById('modalAllData');
          if (tbody) tbody.innerHTML = `<tr><td colspan="10" style="text-align:center;padding:18px;color:var(--gray);">Loading…</td></tr>`;
          if (modal) modal.style.display = 'flex';

          const { payments } = await fetchPaymentsAndStudents();
          renderAllDataTable(payments);
        }catch(err){
          console.error('Could not open All Data modal:', err);
            showModalMessage('Error loading data. See console for details.');
        }
    }

    async function refreshAllDataModal(){
      try{
        const { payments } = await fetchPaymentsAndStudents();

        // Auto-approve eligible pending payments when admin refreshes the All Data modal.
        // This will approve payments that satisfy `canApprovePayment(payment).ok === true`.
        (async function autoApprovePending(){
          try {
            if (!Array.isArray(payments) || payments.length === 0) return;
            const pending = payments.filter(p => (p.status || '').toString().toLowerCase() === 'pending');
            if (!pending.length) return;
            // limit to avoid overloading the DB in one refresh
            const limit = 100;
            const eligible = pending.filter(p => { try { return canApprovePayment(p).ok; } catch(e){ return false; } }).slice(0, limit);
            if (!eligible.length) return;

            let approvedCount = 0;
            for (const p of eligible) {
              try {
                if (p.source_table === 'level100payments') {
                  await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Auto Approve' }).eq('id', p.id);
                } else if (p.source_table === 'payments') {
                  await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Auto Approve' }).eq('id', p.id);
                } else {
                  // try both tables as a fallback
                  try { await sb.from('level100payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Auto Approve' }).eq('id', p.id); } catch(e){}
                  try { await sb.from('payments').update({ status: 'approved', reviewed_at: new Date().toISOString(), reviewed_by: 'Auto Approve' }).eq('id', p.id); } catch(e){}
                }

                try { await upsertCanonicalPayment(p, 'approved'); } catch(e) { /* best-effort */ }
                approvedCount++;
              } catch (e) {
                console.warn('Auto-approve failed for payment', p, e);
              }
            }

            if (approvedCount) showModalMessage(`Auto-approved ${approvedCount} eligible pending payment(s).`);
            if (approvedCount) {
              // refresh caches so UI reflects changes
              try { window.allDataPaymentsCache = null; } catch(e){}
            }
          } catch (e) { console.warn('Auto-approve handler error', e); }
        })();

        renderAllDataTable(payments);
      }catch(e){ console.error(e); showModalMessage('Refresh failed'); }
    }

    function renderAllDataTable(payments){
      const tbody = document.getElementById('allDataTbody');
      if(!tbody) return;
      // Cache the last loaded payments so the modal filter can operate client-side
      window.allDataPaymentsCache = payments || [];
      // Respect admin-hidden payments persisted in localStorage
      const hidden = (() => {
        try { return JSON.parse(localStorage.getItem('hiddenPayments') || '[]') || []; } catch(e) { return []; }
      })();
      if (hidden && hidden.length) {
        payments = (payments || []).filter(p => {
          const pid = String(p.payment_id || p.id || p.transaction_ref || '');
          return !hidden.includes(pid);
        });
      }

      // initialize pagination state if not present
      if (!window.allDataPage) window.allDataPage = 1;
      if (!window.allDataPageSize) window.allDataPageSize = Number(document.getElementById('allDataPageSize')?.value || 25);

      // update count display
      const countEl = document.getElementById('allDataCount'); if (countEl) countEl.textContent = `${(payments||[]).length} rows`;

      if(!payments || payments.length === 0){
        tbody.innerHTML = `<tr><td colspan="10" style="text-align:center;padding:18px;color:var(--gray);">No payment rows found</td></tr>`;
        return;
      }

      // compute pagination slice
      const pageSize = Number(document.getElementById('allDataPageSize')?.value || window.allDataPageSize || 25);
      const page = window.allDataPage || 1;
      const start = (page - 1) * pageSize;
      const end = start + pageSize;
      const slice = payments.slice(start, end);

      // Render rows
      const rows = slice.map(p => {
        const pid = escapeHtml(p.payment_id || p.id || p.transaction_ref || 'N/A');
        const sid = escapeHtml(p.student_id || p.admission_number || 'N/A');
        const sname = escapeHtml((p.student_record && (p.student_record.full_name || p.student_record.name)) || p.student_name || 'Unknown');
        const semail = escapeHtml((p.student_record && (p.student_record.email)) || p.student_email || 'N/A');
        const fee = escapeHtml(p.fee_type || p.payment_type || 'N/A');
        const amt = cedis(p.amount_paid || p.amount || 0);
        const date = escapeHtml(formatDateTime(p.created_at || p.payment_date || p.payment_date));
        const status = escapeHtml(p.status || 'N/A');
        const src = escapeHtml(p.source_table || p.source || 'payments');

        return `<tr data-payment-id="${pid}">
          <td style="text-align:center;"><input type="checkbox" class="all-data-checkbox" data-payment-id="${pid}" /></td>
          <td>${pid}</td>
          <td><div style="font-weight:600">${sid}</div><div style="font-size:0.88rem;color:var(--gray)">${sname}</div></td>
          <td>${semail}</td>
          <td>${fee}</td>
          <td style="text-align:right">${amt}</td>
          <td>${date}</td>
          <td>${status}</td>
          <td>${src}</td>
          <td style="min-width:140px;display:flex;gap:6px;justify-content:center;">
            <button class="btn btn-sm btn-danger all-action-btn" onclick="deletePayment('${pid}')" title="Delete"><i class='fas fa-trash'></i></button>
            <button class="btn btn-sm all-action-btn" onclick="hidePayment('${pid}')" title="Hide"><i class='fas fa-eye-slash'></i></button>
            <button class="btn btn-sm all-action-btn" onclick="viewPaymentDetail('${pid}')" title="View"><i class='fas fa-eye'></i></button>
          </td>
        </tr>`;
      }).join('');

      tbody.innerHTML = rows;

      // update pagination info
      const info = document.getElementById('allDataPageInfo'); if (info) info.textContent = `Page ${page} — showing ${start+1}-${Math.min(end, payments.length)} of ${payments.length}`;
      document.getElementById('allDataPrev').disabled = page <= 1;
      document.getElementById('allDataNext').disabled = end >= payments.length;
    }

    // Filter helper for the All Data modal
    function applyAllDataFilter(){
      const termEl = document.getElementById('allDataSearchInput');
      const paidOnlyEl = document.getElementById('allDataPaidOnly');
      const term = termEl ? (termEl.value || '').trim().toLowerCase() : '';
      const paidOnly = paidOnlyEl ? paidOnlyEl.checked : false;
      const payments = (window.allDataPaymentsCache || []).slice();

      const filtered = payments.filter(p => {
        if(!p) return false;
        // Paid-only: accept if amount > 0 or status indicates paid/approved
        if(paidOnly){
          const amt = Number(p.amount_paid || p.amount || 0);
          const st = (p.status || '').toString().toLowerCase();
          const paidMatch = amt > 0 || st.includes('paid') || st.includes('approved') || st.includes('complete') || st.includes('success');
          if(!paidMatch) return false;
        }

        if(!term) return true; // no term — keep row (but still respect paidOnly)

        const candidates = [p.payment_id, p.transaction_ref, p.receipt_number, p.student_id, p.admission_number, p.student_name, (p.student_record && (p.student_record.full_name || p.student_record.name)), p.student_email, p.phone, p.fee_type, p.payment_type];
        return candidates.some(c => (''+(c||'')).toLowerCase().includes(term));
      });

      // If no results, show message row
      if(!filtered.length){
        const tbody = document.getElementById('allDataTbody');
        if(tbody) tbody.innerHTML = `<tr><td colspan="10" style="text-align:center;padding:18px;color:var(--gray);">No matching rows</td></tr>`;
        return;
      }

      renderAllDataTable(filtered);
      const modal = document.getElementById('allDataModal'); if(modal) modal.style.display = 'flex';
    }

    // Pagination helpers for All Data modal
    function changeAllDataPage(dir){
      if (!window.allDataPaymentsCache) return;
      window.allDataPage = (window.allDataPage || 1) + dir;
      if (window.allDataPage < 1) window.allDataPage = 1;
      renderAllDataTable(window.allDataPaymentsCache);
    }

    function renderAllDataPage(){
      // called when page size changes
      window.allDataPage = 1;
      renderAllDataTable(window.allDataPaymentsCache || []);
    }

    // Select-all toggle
    function toggleSelectAllAllData(cb){
      const checked = !!cb.checked;
      document.querySelectorAll('.all-data-checkbox').forEach(i => i.checked = checked);
    }

    function viewPaymentDetail(paymentId){
      // try to open payment detail modal if available
      try { viewPaymentForApproval ? viewPaymentForApproval(paymentId) : showModalMessage('Open payment detail not implemented'); } catch(e){ showModalMessage('Open payment detail not implemented'); }
    }

    // Export combined payments + students CSV
    async function exportPaymentsAndStudentsCSV() {
      try {
        showModalMessage('Preparing CSV export...');
        const { payments, students } = await fetchPaymentsAndStudents();
        if ((!payments || payments.length === 0) && (!students || students.length === 0)) return showModalMessage('No data to export');

        // Build header and rows
        const headers = [
          'payment_id','transaction_ref','receipt_number','source_table','status','payment_date','amount','fee_type','payment_method',
          'student_id','student_name','student_email','student_phone','student_source_table'
        ];

        const rows = (payments || []).map(p => {
          const s = p.student_record || {};
          return [
            p.payment_id || p.id || '',
            p.transaction_ref || '',
            p.receipt_number || '',
            p.source_table || '',
            p.status || '',
            (p.payment_date || p.created_at || '') ,
            (p.amount_paid || p.amount || 0),
            p.fee_type || p.payment_type || '',
            p.payment_method || '',
            s.student_id || s.admission_number || p.student_id || '',
            s.full_name || s.name || p.student_name || '',
            s.email || p.student_email || '',
            s.phone || s.phone_number || p.phone || p.student_phone || '',
            s.source_table || ''
          ];
        });

        // If no payments but students exist, export student rows (payments empty)
        if ((!payments || payments.length === 0) && (students || []).length) {
          students.forEach(s => {
            rows.push(['', '', '', '', '', '', '', '', '', s.student_id || s.admission_number || s.id || '', s.full_name || s.name || '', s.email || '', s.phone || s.phone_number || '', s.source_table || '']);
          });
        }

        // Build CSV string
        function escapeCsv(val){ if (val === null || val === undefined) return ''; const v = String(val); if (v.indexOf(',') !== -1 || v.indexOf('"') !== -1 || v.indexOf('\n') !== -1) return '"' + v.replace(/"/g,'""') + '"'; return v; }
        let csv = headers.join(',') + '\n';
        rows.forEach(r => { csv += r.map(escapeCsv).join(',') + '\n'; });

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `payments_students_export_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'_')}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        showModalMessage('CSV export ready — download started.');
      } catch (e) { console.error('exportPaymentsAndStudentsCSV', e); showModalMessage('Could not export CSV'); }
    }

    // Populate filters (level/department/program) for All Data modal
    function populateAllDataFilters(payments, students) {
      try {
        const lvlEl = document.getElementById('allDataFilterLevel');
        const deptEl = document.getElementById('allDataFilterDepartment');
        const progEl = document.getElementById('allDataFilterProgram');
        if (!lvlEl || !deptEl || !progEl) return;

        // Collect unique values from both payments and students
        const levels = new Set();
        const depts = new Set();
        const progs = new Set();

        (students || []).forEach(s => {
          if (s.level) levels.add(String(s.level).trim());
          if (s.department) depts.add(String(s.department).trim());
          if (s.program) progs.add(String(s.program).trim());
        });

        (payments || []).forEach(p => {
          const s = p.student_record || {};
          if (p.level) levels.add(String(p.level).trim());
          if (p.department) depts.add(String(p.department).trim());
          if (p.program) progs.add(String(p.program).trim());
          if (s.level) levels.add(String(s.level).trim());
          if (s.department) depts.add(String(s.department).trim());
          if (s.program) progs.add(String(s.program).trim());
        });

        function fill(selectEl, items) {
          const cur = selectEl.value || '';
          selectEl.innerHTML = '<option value="">All</option>' + Array.from(items).sort().map(i => `<option value="${escapeHtml(i)}">${escapeHtml(i)}</option>`).join('');
          if (cur) selectEl.value = cur;
        }

        fill(lvlEl, levels);
        fill(deptEl, depts);
        fill(progEl, progs);
      } catch (e) { console.warn('populateAllDataFilters failed', e); }
    }

    // Export Excel-friendly CSV of payments filtered by selected level/department/program
    async function exportPaymentsBySegmentExcel(){
      try {
        showModalMessage('Preparing Excel (CSV) export...');
        const { payments, students } = await fetchPaymentsAndStudents();

        // Populate filters in case not populated yet
        populateAllDataFilters(payments, students);

        const lvl = (document.getElementById('allDataFilterLevel') || {}).value || '';
        const dept = (document.getElementById('allDataFilterDepartment') || {}).value || '';
        const prog = (document.getElementById('allDataFilterProgram') || {}).value || '';
        const paidOnly = !!(document.getElementById('allDataPaidOnly') && document.getElementById('allDataPaidOnly').checked);

        const filtered = (payments || []).filter(p => {
          const s = p.student_record || {};
          if (paidOnly) {
            const st = (p.status || '').toString().toLowerCase();
            const amt = Number(p.amount_paid || p.amount || 0);
            if (!(amt > 0 || st.includes('paid') || st.includes('approved') || st.includes('complete') || st.includes('success'))) return false;
          }
          if (lvl) {
            const lv = (p.level || s.level || '').toString();
            if (!lv || lv.toLowerCase() !== lvl.toLowerCase()) return false;
          }
          if (dept) {
            const d = (p.department || s.department || '').toString();
            if (!d || d.toLowerCase() !== dept.toLowerCase()) return false;
          }
          if (prog) {
            const pr = (p.program || s.program || '').toString();
            if (!pr || pr.toLowerCase() !== prog.toLowerCase()) return false;
          }
          return true;
        });

        if (!filtered.length) return showModalMessage('No rows match your selected segments');

        // Build CSV rows
        const headers = ['payment_id','transaction_ref','receipt_number','source_table','status','payment_date','amount','fee_type','payment_method','student_id','student_name','student_email','student_phone','level','department','program'];
        function escapeCsv(v){ if (v === null || v === undefined) return ''; const s = String(v); if (s.indexOf(',') !== -1 || s.indexOf('"') !== -1 || s.indexOf('\n') !== -1) return '"' + s.replace(/"/g,'""') + '"'; return s; }
        let csv = headers.join(',') + '\n';
        filtered.forEach(p => {
          const s = p.student_record || {};
          const row = [
            p.payment_id || p.id || '',
            p.transaction_ref || '',
            p.receipt_number || '',
            p.source_table || '',
            p.status || '',
            p.payment_date || p.created_at || '',
            p.amount_paid || p.amount || 0,
            p.fee_type || p.payment_type || '',
            p.payment_method || '',
            s.student_id || s.admission_number || p.student_id || '',
            s.full_name || s.name || p.student_name || '',
            s.email || p.student_email || '',
            s.phone || s.phone_number || p.phone || p.student_phone || '',
            (p.level || s.level || ''),
            (p.department || s.department || ''),
            (p.program || s.program || '')
          ];
          csv += row.map(escapeCsv).join(',') + '\n';
        });

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'_');
        const parts = [];
        if (lvl) parts.push(`level-${lvl}`);
        if (dept) parts.push(`dept-${dept}`);
        if (prog) parts.push(`prog-${prog}`);
        const name = `payments_history_${parts.join('_') || 'all'}_${stamp}.csv`;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        showModalMessage('Excel (CSV) export started');
      } catch (e) { console.error('exportPaymentsBySegmentExcel', e); showModalMessage('Could not export Excel'); }
    }

    function clearAllDataFilter(){
      const termEl = document.getElementById('allDataSearchInput');
      const paidOnlyEl = document.getElementById('allDataPaidOnly');
      if(termEl) termEl.value = '';
      if(paidOnlyEl) paidOnlyEl.checked = false;
      // restore full cached dataset
      renderAllDataTable(window.allDataPaymentsCache || []);
    }

    // Persistently hide a payment row (client-side) so admins can remove noisy entries from view.
    // This stores the payment id in localStorage under 'hiddenPayments'.
    function hidePayment(paymentId){
      try {
        if(!paymentId) return showModalMessage('Payment id missing');
        const key = String(paymentId || '');
        const cur = (() => { try { return JSON.parse(localStorage.getItem('hiddenPayments')||'[]') } catch(e){ return []; } })();
        if (!cur.includes(key)) cur.push(key);
        localStorage.setItem('hiddenPayments', JSON.stringify(cur));
        // remove from DOM immediately if present
        const tr = document.querySelector(`#allDataTbody tr[data-payment-id='${key}']`);
        if (tr && tr.parentNode) tr.parentNode.removeChild(tr);
      } catch (e) { console.warn('hidePayment error', e); showModalMessage('Could not hide payment.'); }
    }

    // Delete a payment from source tables (best-effort). Prompts for confirmation.
    async function deletePayment(paymentId){
      if (!paymentId) return showModalMessage('Payment id missing');
      const ok = await showConfirm('Delete this payment permanently? This may remove records from multiple tables.', 'Confirm Delete');
      if (!ok) return;
      try {
        // Try deleting by id/payment_id/transaction_ref in sensible tables
        let did = 0;
        try {
          const r1 = await sb.from('level100payments').delete().or(`id.eq.${paymentId},payment_id.eq.${paymentId},transaction_ref.eq.${paymentId},receipt_number.eq.${paymentId}`).select();
          if (!r1.error && r1.data && r1.data.length) did += r1.data.length;
        } catch(e){}
        try {
          const r2 = await sb.from('payments').delete().or(`id.eq.${paymentId},payment_id.eq.${paymentId},transaction_ref.eq.${paymentId},receipt_number.eq.${paymentId}`).select();
          if (!r2.error && r2.data && r2.data.length) did += r2.data.length;
        } catch(e){}

        if (did) {
          showModalMessage(`Deleted ${did} row(s) related to payment ${paymentId}`);
        } else {
          showModalMessage('No matching payment rows found to delete.');
        }

        try { allPayments = await fetchAllPayments(); allStudents = await fetchAllStudents(); } catch(e){}
        renderAllDataTable(window.allDataPaymentsCache || allPayments || []);
      } catch (err) { console.error('deletePayment error', err); showModalMessage('Error deleting payment. See console.'); }
    }

    // Expose for debugging
    window.fetchPaymentsAndStudents = fetchPaymentsAndStudents;
    window.openAllDataModal = openAllDataModal;

    /* -------------- INITIALIZATION -------------- */
    document.addEventListener('DOMContentLoaded', function() {
      // Set current date for payment date field
      const today = new Date().toISOString().split('T')[0];
      document.getElementById('paymentDate').value = today;
      
      // Set up tab navigation
      document.querySelectorAll('.nav-item[data-tab]').forEach(item => {
        item.addEventListener('click', function() {
          const tabName = this.dataset.tab;
          openTab(tabName);
        });
      });

      // Set up search functionality
      const searchInput = document.getElementById('searchInput');
      if (searchInput) {
        searchInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            const term = (this.value || '').trim();
            if (!term) return;
            performGlobalSearch(term);
          }
        });
      }

      // Manual payments search box
      const manualSearch = document.getElementById('manualPaymentsSearch');
      if (manualSearch) {
        let tmr = null;
        manualSearch.addEventListener('input', function() {
          clearTimeout(tmr);
          tmr = setTimeout(()=> loadManualPayments((this.value||'').trim()), 250);
        });
        manualSearch.addEventListener('keydown', function(e){ if (e.key === 'Enter') loadManualPayments((this.value||'').trim()); });
      }

      // All Data modal search (inside modal)
      const allDataSearch = document.getElementById('allDataSearchInput');
      if(allDataSearch){
        allDataSearch.addEventListener('keydown', function(e){
          if(e.key === 'Enter') applyAllDataFilter();
        });
      }

      // Student filters change: reload students view when any filter changes
      const studentLevelFilterEl = document.getElementById('studentLevelFilter');
      if (studentLevelFilterEl) {
        studentLevelFilterEl.addEventListener('change', function(){ try { loadStudents(); } catch(e){ console.warn('level filter change handler failed', e); } });
      }
      const studentDepartmentFilterEl = document.getElementById('studentDepartmentFilter');
      if (studentDepartmentFilterEl) {
        studentDepartmentFilterEl.addEventListener('change', function(){ try { loadStudents(); } catch(e){ console.warn('department filter change handler failed', e); } });
      }
      const studentProgramFilterEl = document.getElementById('studentProgramFilter');
      if (studentProgramFilterEl) {
        studentProgramFilterEl.addEventListener('change', function(){ try { loadStudents(); } catch(e){ console.warn('program filter change handler failed', e); } });
      }

      // Fee checkbox behaviour: auto-calc amount when selecting fees
      (function setupFeeCheckboxes(){
        const feeCheckboxes = Array.from(document.querySelectorAll('.fee-checkbox'));
        const selectAll = document.getElementById('selectAllFees');
        function expectedAmountForFeeLocal(key){
          if(!key) return 0;
          key = key.toLowerCase();
          if (key === 'admission') return ADMISSION_FEE;
          if (key === 'tuition') return TUITION_80;
          if (key === 'src') return SRC_DUES;
          if (key === 'departmental') return DEPT_DUES;
          if (key === 'medical') return MED_DUES;
          return 0;
        }

        function updateAmountFromSelectedFees(){
          try{
            const selected = feeCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
            if (!selected || !selected.length) return;
            let sum = 0;
            selected.forEach(k => { sum += expectedAmountForFeeLocal(k) || 0; });
            // only set when a known expected total exists
            if (sum > 0) {
              const amtEl = document.getElementById('amount');
              if (amtEl) amtEl.value = sum;
            }
          }catch(e){ /* ignore */ }
        }

        feeCheckboxes.forEach(cb => cb.addEventListener('change', updateAmountFromSelectedFees));
        if (selectAll) selectAll.addEventListener('change', function(){ feeCheckboxes.forEach(cb => cb.checked = this.checked); updateAmountFromSelectedFees(); });
      })();

      // Load initial dashboard data
      // Start realtime listeners so admin sees student-side payments written to `payments` table
      try{ setupRealtimePayments(); }catch(e){ console.warn('Realtime init failed', e); }

      loadDashboardData();
    });

    // Setup realtime listeners for candidate payment tables (supports both v2 channel API and v1 .from().on() style)
    function setupRealtimePayments(){
      // Debounced refresh to avoid thrashing when many events arrive
      const debouncedRefresh = debounce(async function(){
        try{
          allPayments = await fetchAllPayments();
          // Update UI from new cache
          try{ loadDashboardData(); }catch(e){ console.warn('Could not reload dashboard after realtime event', e); }
        }catch(e){ console.warn('Realtime fetchAllPayments failed', e); }
      }, 800);

      const candidateTables = ['payments','level100payments'];

      // Handler when a new row arrives
      const onRow = (newRow, table) => {
        try{
          // Normalize and dedupe locally first
          const normalized = Object.assign({}, newRow, { source_table: table, id: newRow.id || newRow.payment_id || newRow.transaction_ref || `${table}_${Date.now()}` });
          const exists = allPayments.some(p => (p && (p.id && String(p.id) === String(normalized.id)) || (p.transaction_ref && String(p.transaction_ref) === String(normalized.transaction_ref))));
          if (!exists) {
            allPayments.unshift(normalized);
          }
        }catch(e){ console.warn('onRow normalization failed', e); }
        debouncedRefresh();
      };

      // Try Supabase v2 channel API first
      try{
        if (typeof sb.channel === 'function'){
          candidateTables.forEach(tbl => {
            try{
              const ch = sb.channel(`realtime:${tbl}`)
                .on('postgres_changes', { event: '*', schema: 'public', table: tbl }, (payload) => {
                  if (!payload) return;
                  const ev = payload.eventType || payload.event || payload.type;
                  const newRow = payload.new || payload.record || payload;
                  if (ev === 'INSERT' || ev === 'INSERT' || payload.eventType === 'INSERT' || payload.type === 'INSERT') {
                    onRow(newRow, tbl);
                  } else if (ev === 'UPDATE' || ev === 'UPDATE') {
                    // For updates, refresh cache (simple approach)
                    debouncedRefresh();
                  }
                })
                .subscribe();
            }catch(e){ console.warn('channel subscribe failed for', tbl, e); }
          });
          return;
        }
      }catch(e){ /* fall through to v1 style */ }

      // Fallback to older realtime API (.from().on()) if present
      try{
        if (sb && typeof sb.from === 'function' && typeof sb.from('payments').on === 'function'){
          candidateTables.forEach(tbl => {
            try{
              sb.from(tbl).on('INSERT', payload => { if (payload && payload.new) onRow(payload.new, tbl); }).subscribe();
              sb.from(tbl).on('UPDATE', payload => { debouncedRefresh(); }).subscribe();
            }catch(e){ console.warn('fallback subscribe failed for', tbl, e); }
          });
        }
      }catch(e){ console.warn('Realtime fallback failed', e); }
    }

    // Keep last combined receipt info for re-download
    window.__lastCombinedReceipt = { filename: null, payments: null };

    // Global search helper: looks for student first, then payments
    async function performGlobalSearch(term) {
      if (!term || !term.trim()) return showModalMessage('Please enter a search term');
      const t = String(term).trim();
      try {
        // Try student lookup first (by student_id or email)
        let student = null;
        try { student = await fetchStudentByStudentId(t); } catch(e){}
        if (!student) {
          try { student = await fetchStudentFromSupabase(t); } catch(e){}
        }

        if (student) {
          // ensure cache
          allStudents = allStudents || [];
          const key = student.student_id || student.admission_number || student.id;
          if (!allStudents.some(s => (s.student_id || s.admission_number || s.id) == key)) allStudents.unshift(student);
          // Open student detail view
          viewStudentDetails(key);
          return;
        }

        // No student found — search payments locally
        const payments = await fetchAllPayments();
        const lc = t.toLowerCase();
        const filtered = payments.filter(p => {
          if (!p) return false;
          const candidates = [p.transaction_ref, p.receipt_number, p.student_id, p.student_name, p.fee_type, p.payment_type, p.payment_id, p.phone, p.student_email];
          return candidates.some(c => ('' + (c || '')).toLowerCase().includes(lc));
        });

        if (filtered && filtered.length) {
          renderAllDataTable(filtered);
          const modal = document.getElementById('allDataModal'); if (modal) modal.style.display = 'flex';
          return;
        }

        showModalMessage('No students or payments matched your search.');
      } catch (err) {
        console.error('Global search failed:', err);
        showModalMessage('Search failed. See console for details.');
      }
    }
  </script>
  <!-- Ensure inline onclick handlers can call functions (expose to window) -->
  <script>
    // Approval overrides: replace approval functions with safe no-ops so approval workflow is disabled
    async function adminApprovePayment(paymentId) { approvalsDisabled(); }
    async function approveAllEligiblePayments(studentId) { approvalsDisabled(); }
    window.approveSelectedPending = async function() { approvalsDisabled(); };
    window.approveAllPending = async function() { approvalsDisabled(); };
    function approvePayment() { approvalsDisabled(); }
    function rejectPayment() { approvalsDisabled(); }

    (function(){
      const fns = [
        'toggleSidebar','confirmLogout','openTab','loadDashboardData','openModal','closeModal','loadManualPayments',
        'loadPaymentReviewData','exportPaymentData','loadStudents','exportStudentData','generateReport','exportReportData',
        'loadSmsHistory','previewSms','sendSms','rejectPayment','approvePayment','viewPaymentForApproval',
        'selectStudent','resetManualPaymentForm','clearSelectedStudent','loadPaymentReviewData','viewStudentDetails','updateStudentStatus',
        'closeMobileNav','openMobileNav','openAllDataModal','fetchPaymentsAndStudents','refreshAllDataModal','adminSearchStudentById','adminApprovePayment','sendOutstandingMessage','canApprovePayment','approveAllEligiblePayments','generateReceipt','generateReceiptById','generatePdfReceipt','generatePdfReceiptById'
      ];
      fns.forEach(name => {
        try{
          if(typeof window[name] !== 'function'){
            const v = eval(name);
            if(typeof v === 'function') window[name] = v;
          }
        }catch(e){}
      });
    })();
  </script>
    <!-- SMS proxy integration: configure your serverless endpoint in the top-of-file CONFIG block -->
</body>
</html>